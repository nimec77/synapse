# SY-16: Phase 15 — Code Refactoring

Status: PRD_READY

## Context / Idea

**Arguments:** SY-16 "Phase 15: Code Refactoring" docs/phase/phase-15.md

**Goal:** Improve internal code quality without changing external behaviour. Eliminate dead code, reduce duplication, and harden the public API surface.

The codebase has accumulated technical debt across 15 phases of feature development. Key issues include:

- **Dead code**: A vestigial `placeholder` module in `synapse-core/src/lib.rs` and three unused `StreamEvent` variants (`ToolCall`, `ToolResult`, `Error`) that were reserved for future use but never adopted by any consumer.
- **Massive duplication**: `deepseek.rs` (840 lines) and `openai.rs` (678 lines) share nearly identical serde types (`ApiMessage`, `ApiRequest`, `StreamingApiRequest`, `ApiResponse`, `Choice`, `ChoiceMessage`, `ApiError`, `ErrorDetail`, `StreamChunk`, `StreamDelta`, `StreamChoice`) and logic (`build_api_messages()`, `complete_request()`, `to_oai_tools()`, `stream_sse()`) — roughly 400 lines of exact duplication.
- **Magic strings**: Role-to-string conversions are hand-written in providers and storage (`"system"`, `"user"`, `"assistant"`, `"tool"`), the `"[DONE]"` SSE marker is hard-coded in two places, and error reply strings are duplicated across Telegram handlers.
- **No structured tracing in core**: `synapse-core` has zero `tracing` instrumentation; `eprintln!` is used for warnings in `mcp/tools.rs` and `cli/main.rs`.
- **Duplicated init logic**: `init_mcp_client()` is copy-pasted across CLI and Telegram main files; the Agent-from-config pattern (create provider, create agent, wire system prompt) is repeated 3 times.
- **Large files**: `repl.rs` is 1168 lines (mixing app state, rendering, and input handling); `main.rs` in the CLI mixes argument parsing with session subcommand handling.
- **Overly broad public API**: `lib.rs` re-exports ~24 items, many never imported by consumer crates.
- **Async convention violation**: `std::fs::create_dir_all()` in `sqlite.rs` blocks the async runtime.

## Goals

1. **Remove dead code** — delete the `placeholder` module and unused `StreamEvent` variants; simplify downstream match arms that reference them.
2. **Extract shared OpenAI-compatible provider base** — create `synapse-core/src/provider/openai_compat.rs` with shared types and logic, reducing `deepseek.rs` and `openai.rs` to thin wrappers (~50-80 lines each).
3. **Extract magic strings into constants and methods** — add `Role::as_str()` and `Role::from_str()` methods; replace manual role-to-string matching; add constants for `SSE_DONE_MARKER`, provider/env-var lookup in factory, `ERROR_REPLY` in Telegram handlers, `DEFAULT_TRACING_DIRECTIVE` in Telegram main.
4. **Add structured tracing to synapse-core** — add `tracing = "0.1"` to `synapse-core/Cargo.toml` and `synapse-cli/Cargo.toml`; instrument the agent (tool loop), providers (HTTP requests), factory (provider creation), storage (session CRUD), config (path resolution), and MCP (tool discovery/execution); replace `eprintln!` with `tracing::warn!`.
5. **Extract shared utility functions** — move `init_mcp_client()` into `synapse-core/src/mcp.rs`; add `Agent::from_config()` factory method to encapsulate system prompt wiring.
6. **Split large files** — split `repl.rs` (1168 lines) into `repl/app.rs`, `repl/render.rs`, `repl/input.rs`, and `repl.rs` (orchestrator); extract `synapse-cli/src/commands.rs` from `main.rs`.
7. **Tighten public API surface and fix async convention** — narrow `lib.rs` re-exports; replace `std::fs::create_dir_all()` with `tokio::fs::create_dir_all().await` in `sqlite.rs`; add `fs` feature to tokio in `synapse-core/Cargo.toml`.

## User Stories

1. **As a contributor**, I want to see no dead code in the codebase so that I do not waste time understanding unused modules and variants.
2. **As a contributor**, I want OpenAI-compatible provider logic centralized in one module so that bug fixes and new features only need to be applied once.
3. **As a contributor**, I want magic strings replaced by typed constants and methods so that refactoring a string value cannot silently break serialization.
4. **As an operator**, I want structured tracing spans in core operations so that I can diagnose latency and failures with standard tracing tools (`RUST_LOG`, file appender, Jaeger).
5. **As a contributor**, I want the MCP initialization and Agent construction patterns extracted into shared helpers so that adding a new interface crate does not require copy-pasting boilerplate.
6. **As a contributor**, I want large files split into focused modules so that code review diffs are smaller and ownership of subsystems is clear.
7. **As a contributor**, I want the public API surface narrowed so that internal refactors do not constitute breaking changes for consumer crates.
8. **As a user**, I want the async runtime never blocked by synchronous filesystem calls so that concurrent request latency is not degraded.

## Main Scenarios

### Scenario 1: Dead Code Removal
1. Remove the `placeholder` module from `synapse-core/src/lib.rs`.
2. Remove unused `StreamEvent` variants (`ToolCall`, `ToolResult`, `Error`).
3. Simplify stream match arms in CLI (`main.rs` and `repl.rs`) that reference the removed variants.
4. Add serde-justification comments on any remaining `#[allow(dead_code)]` annotations (e.g., `finish_reason` deserialization fields).
5. Verify: `cargo clippy -- -D warnings` passes; `cargo test` green.

### Scenario 2: OpenAI-Compat Extraction
1. Create `synapse-core/src/provider/openai_compat.rs`.
2. Move shared serde types: `ApiMessage`, `ApiRequest`, `StreamingApiRequest`, `OaiTool`, `OaiFunction`, `OaiToolCall`, `OaiToolCallFunction`, `ApiResponse`, `Choice`, `ChoiceMessage`, `ApiError`, `ErrorDetail`, `StreamChunk`, `StreamDelta`, `StreamChoice`.
3. Move shared functions: `build_api_messages()`, `complete_request()`, `to_oai_tools()`, `stream_sse()`.
4. Reduce `deepseek.rs` and `openai.rs` to thin wrappers (~50-80 lines each) that configure the endpoint URL and model, delegating all logic to `openai_compat`.
5. Verify: all existing tests pass unchanged; no public API regressions.

### Scenario 3: Constants and Methods
1. Add `Role::as_str(&self) -> &'static str` returning `"system"`, `"user"`, `"assistant"`, `"tool"`.
2. Add `Role::from_str(s: &str) -> Option<Role>` (or implement `std::str::FromStr`).
3. Replace all manual `match m.role { ... => "user".to_string() }` in providers and SQLite storage.
4. Add `const SSE_DONE_MARKER: &str = "[DONE]"` in `openai_compat.rs`.
5. Add `const ERROR_REPLY: &str = "Sorry, I encountered an error. Please try again."` in Telegram handlers.
6. Add `const DEFAULT_TRACING_DIRECTIVE: &str = "synapse_telegram=info"` in Telegram main.
7. Add constants for env-var names in provider factory (`DEEPSEEK_API_KEY`, etc.).

### Scenario 4: Structured Tracing
1. Add `tracing = "0.1"` to `synapse-core/Cargo.toml` and `synapse-cli/Cargo.toml`.
2. Instrument the agent tool loop (`Agent::complete`), HTTP requests in providers, provider factory creation, storage session CRUD, config path resolution, and MCP tool discovery/execution.
3. Replace `eprintln!` in `mcp/tools.rs` and `cli/main.rs` with `tracing::warn!`.
4. Verify: `cargo clippy -- -D warnings` passes; no test regressions.

### Scenario 5: Shared Utility Extraction
1. Move `init_mcp_client()` from both CLI `main.rs` and Telegram `main.rs` into `synapse-core/src/mcp.rs` (or a new `synapse-core/src/mcp/init.rs`).
2. Add `Agent::from_config(config: &Config, mcp_client: Option<McpClient>) -> Self` factory method that encapsulates the provider-creation and system-prompt-wiring pattern currently duplicated 3 times (CLI one-shot, CLI REPL, Telegram).
3. Update all call sites to use the shared helpers.

### Scenario 6: File Splitting
1. Split `repl.rs` (1168 lines) into: `repl/app.rs` (state machine / app struct), `repl/render.rs` (TUI rendering), `repl/input.rs` (key event handling), and `repl.rs` (public `run_repl` orchestrator that re-exports the module).
2. Extract `synapse-cli/src/commands.rs` from `main.rs` containing `handle_command()`, `SessionAction`, and related helpers (`truncate`).
3. Verify: `cargo build` and `cargo test` pass.

### Scenario 7: API Surface and Async Fix
1. Audit `lib.rs` re-exports against actual imports in `synapse-cli` and `synapse-telegram`.
2. Remove re-exports that are never imported by consumer crates (~16 items).
3. Replace `std::fs::create_dir_all()` with `tokio::fs::create_dir_all().await` in `sqlite.rs`.
4. Add `fs` feature to tokio in `synapse-core/Cargo.toml`.
5. Verify: all crates compile; `cargo test` green.

## Success / Metrics

| Metric | Target |
|--------|--------|
| `cargo clippy -- -D warnings` | Zero warnings throughout |
| `cargo test` | All tests green after every task |
| DeepSeek provider lines | ~50-80 (down from 840) |
| OpenAI provider lines | ~50-80 (down from 678) |
| `repl.rs` lines | Orchestrator only (~50-100); logic distributed across submodules |
| Public re-exports in `lib.rs` | Only items actually imported by consumer crates |
| Blocking `std::fs` calls in async context | Zero |
| `eprintln!` in core and CLI | Zero (replaced by `tracing::warn!`) |
| Duplicated `init_mcp_client()` | Single source of truth in `synapse-core` |
| External behaviour changes | Zero |

## Constraints and Assumptions

1. **No external behaviour changes** — all refactoring is purely internal. CLI output, Telegram bot responses, API interactions, and database schema must remain identical.
2. **Task ordering** — Task 15.1 (dead code removal) must complete before 15.2 (OpenAI-compat extraction) to avoid carrying dead variants into the new shared module. Task 15.2 should complete before 15.3 and 15.4.
3. **Pre-commit gate after every task** — `cargo fmt --check && cargo clippy -- -D warnings && cargo test` must pass after each completed task.
4. **No new `mod.rs` files** — follow Rust 2018+ module convention as per `docs/conventions.md`.
5. **No `unwrap()`/`expect()` in `synapse-core`** — all error handling via `?` propagation.
6. **Tracing, not logging** — use `tracing` crate (not `log`) for consistency with the existing Telegram tracing setup.
7. **Phase 14 (system prompt, file logging) is complete** — this work builds on a stable baseline.

## Risks

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| Breaking public API for consumer crates during re-export narrowing | Medium | Medium | Audit actual imports in `synapse-cli` and `synapse-telegram` before removing any re-export; verify all crates compile after each change. |
| OpenAI-compat extraction introduces subtle provider-specific regressions | Medium | High | Keep all existing tests; run full test suite after extraction; verify serialization output matches before-and-after for both providers. |
| `repl.rs` split breaks TUI state machine | Low | Medium | Split incrementally: extract one submodule at a time and verify `cargo build` after each. |
| Adding `tracing` to core creates dependency bloat | Low | Low | `tracing` is already a transitive dependency via `tracing-subscriber` in `synapse-telegram`; adding it to core adds zero new crates. |
| `tokio::fs` feature addition increases compile time | Low | Low | Minimal impact; `tokio` is already a dependency with several features enabled. |

## Open Questions

None — the description file is comprehensive and all specifications are clear. The PRD is ready for tasklist creation.
