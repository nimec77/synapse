# SY-19: Telegram Command Fixes & Interactive Keyboards

Status: PRD_READY

## Context / Idea

Slash commands in the Telegram bot (`/switch`, `/delete`) silently fall through to the LLM when invoked without an argument. The root cause is that `Switch(usize)` and `Delete(usize)` in the `Command` enum cause `BotCommands::parse` to fail when no argument is provided (empty string cannot parse to `usize`). Since `filter_command` uses `.ok()` to convert parse errors to `None`, the entire command branch is rejected and the message falls through to `handle_message`, which forwards it to the LLM as a regular user message.

Additionally, the bot lacks a `/start` command (the standard Telegram bot welcome), and there is no defensive guard to prevent future regressions where unhandled commands slip through to the LLM.

This ticket fixes the command parsing, adds a `/start` welcome message, implements a defensive guard against command fall-through, and introduces interactive inline keyboards for `/switch` and `/delete` so users can select sessions by tapping buttons instead of remembering indices.

**Source:** `docs/phase/phase-19.md`

### Current Code State (Gaps)

- `Command::Switch(usize)` and `Command::Delete(usize)` in `synapse-telegram/src/commands.rs` (lines 35-38) fail to parse when the argument is empty, causing the fall-through bug.
- No `Start` variant in the `Command` enum.
- No defensive guard in `handlers::handle_message` to catch commands that slip past `filter_command`.
- No `CallbackQuery` handler or inline keyboard support anywhere in the codebase.
- The dispatcher in `main.rs` (line 194) only handles `Update::filter_message()` -- no branch for `Update::filter_callback_query()`.

## Goals

1. **Fix command fall-through**: Ensure `/switch` and `/delete` (with or without arguments) are always handled by the command dispatcher, never forwarded to the LLM.
2. **Add `/start` command**: Provide the standard Telegram bot welcome message when a user first interacts with the bot.
3. **Defensive guard**: Prevent any slash command from being forwarded to the LLM, even if `filter_command` fails to parse it.
4. **Interactive session selection**: When `/switch` or `/delete` is used without an argument, display an inline keyboard with one button per session so the user can tap to select.
5. **Callback query handling**: Process `CallbackQuery` updates from inline keyboard button taps, executing the switch/delete action and removing the keyboard afterward.
6. **Shared logic**: Refactor switch/delete core logic into reusable functions (`do_switch()` / `do_delete()`) so both the slash-command path and the callback path share the same implementation.

## User Stories

1. **As a Telegram user**, I want `/switch` without an argument to show me a list of sessions as clickable buttons, so I can switch sessions without memorizing index numbers.
2. **As a Telegram user**, I want `/delete` without an argument to show me a list of sessions as clickable buttons, so I can delete a session by tapping it.
3. **As a Telegram user**, I want `/switch 2` and `/delete 3` to continue working as before (direct execution with a numeric argument).
4. **As a Telegram user**, I want `/start` to show a welcome message when I first open the bot.
5. **As a Telegram user**, I want unknown or malformed commands (e.g., `/switch abc` or `/foo`) to produce a helpful hint instead of being sent to the LLM as a conversation message.
6. **As a Telegram user**, I want the inline keyboard to disappear after I tap a button, replaced by a confirmation message, so I cannot accidentally double-tap.

## Main Scenarios

### Scenario 1: `/switch` with no argument (keyboard flow)

1. User sends `/switch` (no number).
2. `BotCommands::parse` succeeds because `Switch(String)` accepts an empty string.
3. `handle_command` dispatches to `cmd_switch`, which calls `parse_session_arg("")`.
4. Empty argument triggers `cmd_switch_keyboard()`, which builds an `InlineKeyboardMarkup` with one button per session.
5. Bot sends the keyboard message to the chat.
6. User taps button for session 2.
7. Telegram sends a `CallbackQuery` with `data = "switch:2"`.
8. `handle_callback` parses the callback data, calls `do_switch(2, ...)`.
9. Bot calls `bot.answer_callback_query(q.id)` immediately.
10. Bot edits the keyboard message to plain text: "Switched to session 2." (keyboard removed).

### Scenario 2: `/switch 3` (direct execution)

1. User sends `/switch 3`.
2. `BotCommands::parse` succeeds, `Switch("3".to_string())`.
3. `handle_command` dispatches to `cmd_switch`, which calls `parse_session_arg("3")`.
4. Numeric argument parsed to `3`, calls `do_switch(3, ...)` directly.
5. Bot replies "Switched to session 3." (no keyboard involved).

### Scenario 3: `/delete` with no argument (keyboard flow)

Same as Scenario 1 but with `delete` action and `cmd_delete_keyboard()`. Callback data format: `"delete:N"`. After execution, keyboard is replaced with confirmation text (e.g., "Session 2 deleted.").

### Scenario 4: `/start` command

1. User opens the bot for the first time and Telegram sends `/start`.
2. `filter_command` parses it as `Command::Start`.
3. `handle_command` dispatches to a handler that replies with a welcome message.

### Scenario 5: Defensive guard catches malformed command

1. User sends `/switch abc` (non-numeric argument).
2. `BotCommands::parse` succeeds because `Switch(String)` accepts any string.
3. `handle_command` dispatches to `cmd_switch`, which calls `parse_session_arg("abc")`.
4. Non-numeric, non-empty string is rejected; bot replies with an error hint (e.g., "Invalid argument. Use /switch N or /switch to see a list.").

### Scenario 6: Defensive guard in handle_message

1. A hypothetical future command is added but `filter_command` fails to parse it.
2. The message reaches `handle_message`.
3. The defensive guard detects the text starts with `/` followed by a known command name.
4. Bot replies with a hint (e.g., "I didn't understand that command. Use /help to see available commands.") instead of forwarding to the LLM.

### Scenario 7: Callback double-tap prevention

1. User taps a keyboard button.
2. `handle_callback` executes the action and edits the message to plain text (keyboard removed).
3. If the user somehow manages to tap again before the edit, `answer_callback_query` still succeeds (idempotent), and the edit is a no-op or produces an innocuous Telegram API error.

## Success / Metrics

- `/help`, `/switch`, `/delete`, `/start`, `/new`, `/history`, `/list` never produce LLM responses -- they always return bot-generated command responses.
- `/switch` and `/delete` without arguments display inline keyboards with correct session listings.
- Tapping a keyboard button executes the action and removes the keyboard.
- `/start` returns a welcome message.
- Unknown commands (text starting with `/`) in `handle_message` are not forwarded to the LLM.
- All existing tests pass; new unit tests cover `parse_session_arg`, `build_session_keyboard` callback data format, and the defensive guard logic.

## Constraints and Assumptions

- **teloxide 0.17**: Must use the teloxide 0.17 API for `InlineKeyboardMarkup`, `CallbackQuery`, and `bot.answer_callback_query()`.
- **dptree dependency injection**: The new `handle_callback` endpoint must receive its dependencies (config, storage, chat_map) via `dptree::deps![]`, matching the existing handler pattern.
- **No confirmation dialogs for `/delete`**: Sessions are cheap to recreate with `/new`. A confirmation dialog would add a third callback state (`confirm_delete:N`) and is not worth the added complexity.
- **Callback data format**: `"switch:N"` and `"delete:N"` where N is a 1-based session index. This is simple and fits within Telegram's 64-byte callback data limit.
- **`answer_callback_query` before DB calls**: Must be called immediately to dismiss the Telegram loading spinner, before any potentially slow storage operations.
- **Edit message to remove keyboard**: After executing the callback action, the original keyboard message is edited to a plain text result string via `bot.edit_message_text`. This prevents accidental double-execution.
- **Existing module conventions**: New code goes in existing files (`commands.rs`, `handlers.rs`, `main.rs`). No new module files needed.
- **No `mod.rs` files**: Per project conventions (Rust 2018+ module system).

## Risks

1. **Callback query staleness**: If sessions are created/deleted between the keyboard being shown and the user tapping a button, the 1-based index may point to the wrong session. **Mitigation**: The callback handler should re-fetch the session list and validate the index before executing. If invalid, reply with an error and remove the keyboard.
2. **Telegram API rate limits**: Editing messages and answering callback queries count against rate limits. **Mitigation**: These are low-frequency user-initiated actions, unlikely to hit limits.
3. **`edit_message_text` failure**: If the message is too old or was already deleted, the edit will fail. **Mitigation**: Log the error but do not propagate it to the user -- the action already succeeded.

## Open Questions

None -- the phase document provides comprehensive specifications for all tasks.
