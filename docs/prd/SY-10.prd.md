# SY-10: Phase 9 — CLI REPL

Status: PRD_READY

## Context / Idea

SY-10 "Phase 9: CLI REPL" — Implement an interactive chat mode for the Synapse CLI.

**From description file (`docs/phase/phase-9.md`):**

- **Goal:** Interactive chat mode.
- **Tasks:**
  - 9.1 Add `ratatui` + `crossterm` to CLI
  - 9.2 Create `synapse-cli/src/repl.rs` with input loop
  - 9.3 Implement `--repl` flag to enter interactive mode
  - 9.4 Add session resume: `synapse --repl --session <id>`
- **Acceptance Criteria:** `synapse --repl` allows multi-turn conversation with history.
- **Dependencies:** Phase 8 complete (Session Storage) — completed as SY-9.

**Current state:** The CLI (`synapse-cli`) currently supports one-shot mode (message as argument or via stdin pipe) and session management subcommands (`sessions list`, `sessions show <id>`, `sessions delete <id>`). Sessions are persisted via SQLite through the `SessionStore` trait. The `--session <id>` flag already allows continuing a session in one-shot mode. The CLAUDE.md already lists `ratatui` + `crossterm` as planned CLI technologies.

## Goals

1. Provide an interactive REPL (Read-Eval-Print Loop) mode for multi-turn conversations.
2. Use `ratatui` + `crossterm` for terminal UI rendering.
3. Support creating new sessions and resuming existing sessions in REPL mode.
4. Display streaming responses token-by-token within the REPL interface.
5. Persist all messages (user and assistant) to session storage during REPL conversations.

## User Stories

1. **As a user**, I want to run `synapse --repl` to enter an interactive chat mode where I can have a multi-turn conversation with an LLM.
2. **As a user**, I want to resume a previous session in REPL mode with `synapse --repl --session <id>` so I can continue a past conversation interactively.
3. **As a user**, I want to see streaming responses appear token-by-token in the REPL so the experience feels responsive.
4. **As a user**, I want to exit the REPL cleanly with Ctrl+C or by typing `/quit`.
5. **As a user**, I want my REPL conversation history to be saved so I can review or resume it later.

## Main Scenarios

### Scenario 1: Start New REPL Session
1. User runs `synapse --repl`
2. System creates a new session, enters interactive mode
3. User types a message, presses Enter
4. System streams the LLM response token-by-token
5. User continues with follow-up messages
6. Each message pair is persisted to session storage

### Scenario 2: Resume Existing Session
1. User runs `synapse --repl --session <uuid>`
2. System loads the session and its message history
3. Previous conversation context is displayed or loaded for the LLM
4. User continues the conversation from where they left off

### Scenario 3: Exit REPL
1. User presses Ctrl+C or types `/quit`
2. System cleanly exits the REPL, restoring terminal state
3. Session ID is printed for future resumption

### Scenario 4: Error Handling
1. If API key is missing or provider fails, show error inline and allow retry
2. If session ID is invalid, show error and exit gracefully
3. Terminal state is always restored on exit (even on panic)

## Success / Metrics

- `synapse --repl` enters interactive mode with a working input loop
- Multi-turn conversations work with conversation history sent to the LLM
- Streaming responses display token-by-token in the terminal
- `synapse --repl --session <id>` loads and resumes an existing session
- All messages are persisted to SQLite session storage
- Terminal state is correctly restored on exit (no corrupted terminal)
- Ctrl+C exits cleanly

## Constraints and Assumptions

- **`ratatui` + `crossterm`**: As specified in the phase description and CLAUDE.md technology decisions.
- **Module path**: `synapse-cli/src/repl.rs` as specified in task 9.2.
- **Flag**: `--repl` flag as specified in task 9.3.
- **Session resume**: `--repl --session <id>` as specified in task 9.4.
- **Hexagonal architecture**: REPL is an interface concern — all REPL code lives in `synapse-cli`, using `synapse-core` traits.
- **Error handling**: `anyhow` in CLI crate, proper terminal cleanup on all exit paths.
- **Rust 2018+ module system**: No `mod.rs` files.

## Risks

1. **Terminal state corruption**: If the REPL crashes without restoring the terminal, the user's terminal may be left in raw mode. Mitigation: use `Drop` guard or `crossterm` cleanup on all exit paths.
2. **ratatui complexity**: `ratatui` is a full TUI framework which may be overly complex for a simple chat REPL. Consider whether a simpler approach (crossterm-only) is sufficient, or whether `ratatui` provides value for layout, scrolling, and future extensibility.
3. **Streaming within TUI**: Rendering streaming tokens inside a `ratatui` widget requires careful event loop integration with `tokio` async streams.

## Open Questions

None — requirements are clear from the phase description and align with existing architecture.
