# SY-13: Phase 12 — Telegram Bot

Status: PRD_READY

## Context / Idea

**Ticket:** SY-13 "Phase 12: Telegram Bot"
**Description file:** `docs/phase/phase-12.md`

Synapse targets three interfaces: CLI (complete, SY-10), Telegram bot, and backend service. The CLI REPL (SY-10) is the primary interface; this ticket introduces the **second interface** — a Telegram bot — proving that the hexagonal architecture works as intended: multiple frontends sharing the same `synapse-core` Agent orchestrator without duplicating business logic.

The `synapse-telegram` crate already exists as a placeholder (created in SY-1) with an empty `main.rs` and no dependencies. This phase brings it to life using `teloxide`, wiring it to the core Agent, SessionStore, and MCP subsystems.

### Source Requirements (from `docs/phase/phase-12.md`)

**Tasks:**
- 12.1 Add `teloxide` to `synapse-telegram`
- 12.2 Create bot initialization with token from config
- 12.3 Implement message handler using `synapse-core` agent
- 12.4 Add session-per-chat persistence
- 12.5 Add user authorization via `allowed_users` allowlist

**Acceptance Criteria:**
- Send message to bot, receive LLM response.
- Messages from unlisted user IDs are silently dropped; only allowlisted users receive responses.

**TelegramConfig struct:**
```toml
[telegram]
token = "..."           # bot token (overridden by TELEGRAM_BOT_TOKEN env var)
allowed_users = [123456789, 987654321]  # Telegram user IDs (u64)
```

```rust
pub struct TelegramConfig {
    pub token: Option<String>,
    pub allowed_users: Vec<u64>,
}
```

**Bot token resolution priority:**
1. `TELEGRAM_BOT_TOKEN` environment variable (highest priority)
2. `telegram.token` in `config.toml`

**User authorization:**
- On every incoming message, check `msg.from().map(|u| u.id.0)` against `allowed_users`.
- **Secure-by-default:** an empty `allowed_users` list rejects all users.
- **Silent drop:** unauthorized messages are ignored without any reply (do not reveal the bot exists).

```rust
async fn handle_message(bot: Bot, msg: Message, cfg: Arc<Config>) -> ResponseResult<()> {
    let user_id = msg.from().map(|u| u.id.0).unwrap_or(0);
    if !cfg.telegram.allowed_users.contains(&user_id) {
        return Ok(()); // silent drop
    }
    // ... forward to agent
}
```

**Dependency:** Phase 11 (MCP Integration) complete.

## Goals

1. **Validate hexagonal architecture** — demonstrate that a second interface crate can use the same `synapse-core` Agent, SessionStore, and MCP subsystems without modifying core code.
2. **Deliver a functional Telegram bot** — users can send messages to the bot and receive LLM-generated responses, including MCP tool usage.
3. **Implement session-per-chat persistence** — each Telegram chat ID maps to a persistent session, enabling multi-turn conversations across restarts.
4. **Enforce user authorization** — only explicitly allowlisted Telegram user IDs can interact with the bot; all others are silently ignored.
5. **Maintain secure defaults** — bot token resolution follows the established env-var-over-config pattern; an empty allowlist rejects everyone.

## User Stories

1. **As a user**, I want to send a text message to the Synapse Telegram bot and receive an LLM-generated response, so I can interact with my AI agent from any device with Telegram.

2. **As a user**, I want my Telegram conversations to persist across bot restarts, so I can continue multi-turn conversations without losing context.

3. **As an operator**, I want to control who can use the bot via an `allowed_users` allowlist in the config, so I can restrict access to trusted Telegram accounts.

4. **As an operator**, I want the bot to silently ignore unauthorized users (no error reply, no acknowledgment), so the bot's existence is not revealed to unintended recipients.

5. **As an operator**, I want to configure the bot token via the `TELEGRAM_BOT_TOKEN` environment variable (with config file fallback), so I can follow standard deployment practices without committing secrets.

6. **As a developer**, I want the Telegram interface to use the same `Agent`, `SessionStore`, and `McpClient` abstractions as the CLI, so there is zero business logic duplication between interfaces.

## Main Scenarios

### Scenario 1: Authorized User Sends a Message

**Given** the bot is running with user ID `123456789` in `allowed_users`
**When** user `123456789` sends "What is Rust?" to the bot
**Then** the bot forwards the message to the `Agent` (with session context), streams or sends the LLM response back to the Telegram chat, and persists the exchange in the session store.

### Scenario 2: Unauthorized User Sends a Message

**Given** the bot is running with `allowed_users = [123456789]`
**When** user `999999999` (not in the allowlist) sends a message
**Then** the bot returns `Ok(())` immediately — no reply, no error, no acknowledgment. The message is silently dropped.

### Scenario 3: Empty Allowlist (Secure Default)

**Given** the config has `allowed_users = []`
**When** any user sends a message to the bot
**Then** every message is silently dropped. No user is authorized.

### Scenario 4: Multi-Turn Conversation Persistence

**Given** user `123456789` has previously chatted with the bot (session exists)
**When** the user sends a follow-up message
**Then** the bot loads the existing session (keyed by Telegram chat ID), appends the new user message, calls the Agent with full conversation history, and persists the response.

### Scenario 5: Bot Startup with Environment Variable Token

**Given** `TELEGRAM_BOT_TOKEN=bot123:ABC` is set in the environment and `telegram.token` is also set in `config.toml`
**When** the bot starts
**Then** the bot uses the environment variable value (`bot123:ABC`), ignoring the config file token.

### Scenario 6: Bot Startup without Token

**Given** neither `TELEGRAM_BOT_TOKEN` env var nor `telegram.token` in config is set
**When** the bot attempts to start
**Then** the bot exits with a clear error message indicating that a bot token is required.

### Scenario 7: MCP Tool Usage via Telegram

**Given** MCP servers are configured and the user is authorized
**When** the user sends a message that triggers tool calls (e.g., "What's the weather?")
**Then** the Agent executes the tool call loop (detect-execute-return) and sends the final text response to the Telegram chat.

## Success / Metrics

| Metric | Target |
|--------|--------|
| Authorized message -> LLM response delivered | 100% success (network permitting) |
| Unauthorized message -> silent drop (no reply sent) | 100% |
| Session persisted per chat ID across bot restarts | Verified by test |
| Bot startup with env var token | Works correctly |
| Bot startup with config file token | Works correctly |
| Bot startup with no token | Exits with clear error |
| All existing `cargo test` continue to pass | Zero regressions |
| `cargo clippy -- -D warnings` clean | Zero warnings |

## Constraints and Assumptions

### Constraints

1. **`synapse-core` must not be modified for Telegram-specific logic.** The core crate remains interface-agnostic. All Telegram-specific code lives in `synapse-telegram`.
2. **`TelegramConfig` must live in `synapse-core/src/config.rs`** as an optional section of `Config`, since the config struct is shared across interfaces.
3. **`teloxide` is the required Telegram library** per `docs/vision.md` and `docs/phase/phase-12.md`.
4. **Error handling:** `synapse-telegram` uses `anyhow` for application-level errors (consistent with `synapse-cli`).
5. **No `mod.rs` files** — new module system (Rust 2018+) per project conventions.
6. **No `unwrap()`/`expect()` in `synapse-core`** — propagate with `?`.
7. **100 character line limit** across all code.
8. **Bot token must not be logged** at any level per security conventions.

### Assumptions

1. Phase 11 (MCP Integration, SY-12) is complete and merged before this work begins.
2. The `Agent` struct's `complete()` and `stream()` methods are the primary interface for message processing — no new core methods are needed.
3. `teloxide` provides a stable `dispatching` module suitable for message handling with shared state (`Arc<Config>`, `Arc<Agent>`, etc.).
4. Telegram's long-polling mode is sufficient for the initial implementation (no webhook server required).
5. A single SQLite database can be shared between the CLI and Telegram bot (with WAL mode handling concurrent access).

## Risks

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| `teloxide` API breaking changes or incompatibility with nightly Rust | Low | High | Pin `teloxide` version in `Cargo.toml`; test with current nightly before starting |
| Telegram rate limits for bot responses | Medium | Medium | Implement basic retry/backoff for `sendMessage` calls; long responses may need chunking |
| Long LLM responses exceeding Telegram's 4096-character message limit | Medium | Medium | Split long responses into multiple Telegram messages |
| Concurrent chat sessions causing SQLite contention | Low | Medium | SQLite WAL mode already configured; connection pooling handles concurrency |
| `Agent` lifetime/borrow issues when shared across async Telegram handlers | Medium | Medium | Wrap `Agent` in `Arc`; use `stream_owned()` to avoid borrow-checker issues |
| Bot token accidentally logged during startup | Low | High | Ensure token is never passed to `tracing` macros; mask in any debug output |

## Open Questions

None — the description file provides sufficient detail to proceed. All technical specifications (config structure, token resolution, authorization logic, session-per-chat mapping) are clearly defined.
