# SY-19 Summary: Telegram Command Fixes & Interactive Keyboards

**Ticket:** SY-19
**Status:** COMPLETE
**Branch:** feature/sy-19-phase19
**Date:** 2026-02-25

---

## Overview

SY-19 fixes a command fall-through bug in the Synapse Telegram bot where `/switch` and `/delete`
without arguments were silently forwarded to the LLM instead of being handled as commands. The root
cause was that `Switch(usize)` and `Delete(usize)` in the `Command` enum caused `BotCommands::parse`
to fail on empty strings, causing the entire command branch to be skipped via `.ok()`. This left
the message to fall through to `handle_message`, which forwarded it to the LLM.

The fix changes those variants to `Switch(String)` and `Delete(String)`, adds a `parse_session_arg`
helper to triage empty / numeric / invalid arguments, adds a `/start` welcome command, adds a
defensive guard in `handle_message` to prevent any slash-prefixed message from reaching the LLM,
introduces interactive inline keyboards for argumentless `/switch` and `/delete`, and restructures
the dispatcher to handle `CallbackQuery` updates from keyboard button taps.

Seven tasks were completed across three files in `synapse-telegram`, with 68 unit tests passing.
All changes are confined to `synapse-telegram`; `synapse-core` is untouched.

---

## What Was Done

### Task 1 — Change Command enum types and add `parse_session_arg` (`commands.rs`)

`Switch(usize)` and `Delete(usize)` were changed to `Switch(String)` and `Delete(String)` in the
`Command` enum. This ensures `BotCommands::parse` always succeeds for argumentless invocations,
eliminating the fall-through bug at its root.

`handle_command` match arms were updated to `Command::Switch(ref arg)` and
`Command::Delete(ref arg)` to pass the argument by reference.

A new `parse_session_arg` function was added to triage the argument string:

```rust
fn parse_session_arg(arg: &str) -> Result<Option<usize>, String> {
    let trimmed = arg.trim();
    if trimmed.is_empty() {
        Ok(None)             // show interactive keyboard
    } else {
        trimmed.parse::<usize>()
            .map(Some)
            .map_err(|_| format!(
                "Invalid argument '{}'. Use a number or omit to see a list.", trimmed
            ))
    }
}
```

`cmd_switch` and `cmd_delete` were updated to accept `arg: &str` and branch on the result of
`parse_session_arg(arg)`.

### Task 2 — Add `Start` variant and `cmd_start` (`commands.rs`)

A `Start` variant was added to the `Command` enum before `Help`:

```rust
#[command(description = "Start the bot")]
Start,
```

`handle_command` was updated with `Command::Start => cmd_start(&bot, &msg).await`. The `cmd_start`
function sends a welcome message:

```
Welcome to Synapse! I'm an AI assistant.

Send me a message to start chatting, or use /help to see available commands.
```

The `/start` command is the standard Telegram bot entry point and is now registered with Telegram
via `set_my_commands` at startup alongside the other six commands, bringing the total to seven.

### Task 3 — Defensive guard in `handle_message` (`handlers.rs`)

A guard was added to `handle_message` immediately after the `text` variable is extracted, before
any LLM call or session resolution:

```rust
if text.starts_with('/') {
    bot.send_message(
        msg.chat.id,
        "I didn't understand that command. Use /help to see available commands.",
    )
    .await?;
    return Ok(());
}
```

This catches: (a) command typos like `/hlep`, (b) future commands that `filter_command` fails to
parse, and (c) commands from other bots in group chats that are not recognized by this bot.
Non-slash messages are unaffected.

### Task 4 — Keyboard builder functions (`commands.rs`)

A `fetch_chat_sessions` helper was added to avoid duplicating the session-fetch-and-filter pattern:

```rust
async fn fetch_chat_sessions(
    chat_id: i64,
    storage: &Arc<Box<dyn SessionStore>>,
    chat_map: &ChatSessionMap,
) -> Option<(Vec<SessionSummary>, Option<Uuid>)>
```

It reads `chat_map` for UUIDs and the active session ID, calls `storage.list_sessions()`, and
filters the results to only those belonging to the given chat.

`build_session_keyboard` constructs an `InlineKeyboardMarkup` from a session list. Each button
contains callback data in `"action:N"` format (1-based index), with the active session marked
by `*` in the label, and the preview text capped at 20 characters:

```rust
fn build_session_keyboard(
    action: &str,
    sessions: &[&SessionSummary],
    active_id: Option<Uuid>,
) -> InlineKeyboardMarkup
```

`cmd_switch_keyboard` and `cmd_delete_keyboard` each call `fetch_chat_sessions`, build the
keyboard with the appropriate action string (`"switch"` or `"delete"`), and send the keyboard
message with a text prompt. If no sessions exist, a plain-text hint is sent instead.

### Task 5 — Extract `do_switch` / `do_delete` and add `handle_callback` (`commands.rs`)

The switch and delete logic was extracted into reusable async functions so that both the
slash-command path and the callback path share the same implementation:

```rust
async fn do_switch(
    n: usize,
    chat_id: i64,
    storage: &Arc<Box<dyn SessionStore>>,
    chat_map: &ChatSessionMap,
) -> Result<String, String>

async fn do_delete(
    n: usize,
    chat_id: i64,
    config: &Config,
    storage: &Arc<Box<dyn SessionStore>>,
    chat_map: &ChatSessionMap,
) -> Result<String, String>
```

Both functions re-fetch the session list from the database on every invocation (via
`fetch_chat_sessions`) to handle staleness if sessions changed between keyboard display and button
tap. `do_switch` validates the 1-based index, updates `active_idx` in `chat_map`, and calls
`storage.touch_session()`. `do_delete` validates the index, removes the session from storage and
the in-memory `sessions` vec, and adjusts `active_idx` using the same four-case logic as SY-18.

`parse_callback_data` parses callback data strings in `"action:N"` format:

```rust
fn parse_callback_data(data: &str) -> Option<(&str, usize)> {
    let (action, n_str) = data.split_once(':')?;
    let n = n_str.parse::<usize>().ok()?;
    Some((action, n))
}
```

`handle_callback` is the public endpoint for `CallbackQuery` updates:

```rust
pub async fn handle_callback(
    bot: Bot,
    q: CallbackQuery,
    config: Arc<Config>,
    storage: Arc<Box<dyn SessionStore>>,
    chat_map: ChatSessionMap,
) -> ResponseResult<()>
```

The handler follows the contract defined in the PRD:
1. Authorization check — silent drop for unauthorized users.
2. `bot.answer_callback_query(q.id.clone())` — dismisses the Telegram loading spinner immediately,
   before any DB operations. `q.id.clone()` is used to avoid borrow-after-move.
3. Guard for missing or empty `q.data`.
4. `q.regular_message()` used to extract the original message; `None` case logs `warn!` and returns.
5. `parse_callback_data(data)` to parse `"switch:N"` / `"delete:N"`.
6. Dispatch to `do_switch` or `do_delete` based on the action string.
7. `bot.edit_message_text(chat_id, message_id, reply)` to replace the keyboard message with plain
   text, preventing double-tap. Edit failures are logged at `warn` level but not propagated.

### Task 6 — Restructure dispatcher (`main.rs`)

The dispatcher was restructured from message-only to a top-level `dptree::entry()` with two branches:

```rust
let handler = dptree::entry()
    .branch(
        Update::filter_message()
            .branch(
                dptree::entry()
                    .filter_command::<commands::Command>()
                    .endpoint(commands::handle_command),
            )
            .branch(dptree::entry().endpoint(handlers::handle_message)),
    )
    .branch(
        Update::filter_callback_query()
            .endpoint(commands::handle_callback),
    );
```

The existing `dptree::deps![]` already provides `config`, `storage`, and `chat_map`, which is
everything `handle_callback` needs. `CallbackQuery` is injected automatically by
`Update::filter_callback_query()`. No new dependencies were added.

### Task 7 — Unit tests (`commands.rs`)

14 required unit tests were added, all pure (no `Bot` instance, no database, no async runtime):

- `test_parse_session_arg_empty` — `Ok(None)` for `""`
- `test_parse_session_arg_whitespace` — `Ok(None)` for `"  "`
- `test_parse_session_arg_numeric` — `Ok(Some(3))` for `"3"`
- `test_parse_session_arg_zero` — `Ok(Some(0))` for `"0"` (index validation deferred to
  `do_switch`/`do_delete`)
- `test_parse_session_arg_non_numeric` — `Err` containing "Invalid argument" for `"abc"`
- `test_parse_session_arg_negative` — `Err` for `"-1"` (fails `usize` parse)
- `test_parse_callback_data_valid_switch` — `Some(("switch", 2))` for `"switch:2"`
- `test_parse_callback_data_valid_delete` — `Some(("delete", 1))` for `"delete:1"`
- `test_parse_callback_data_invalid_no_colon` — `None` for `"switch2"`
- `test_parse_callback_data_invalid_non_numeric` — `None` for `"switch:abc"`
- `test_build_session_keyboard_callback_data` — two buttons with `"switch:1"` and `"switch:2"`
- `test_build_session_keyboard_active_marker` — `*` in active session button label
- `test_build_session_keyboard_empty_sessions` — empty sessions produce empty keyboard
- `test_defensive_guard_slash_detection` — `"/"`, `"/foo"`, `"/switch"` satisfy
  `starts_with('/')`; `"hello"` does not

An additional 11 tests were added covering session index management and `active_idx` adjustment
logic for `do_delete` edge cases (active session with others remaining, active session with no
sessions remaining, non-active below active, non-active above active).

The pre-commit gate (`cargo fmt --check && cargo clippy -- -D warnings && cargo test`) passed
with 68 unit tests green, zero regressions against the 43 pre-existing tests.

---

## Key Design Decisions

**`Switch(String)` and `Delete(String)` instead of `usize`** — The root cause of the fall-through
bug was that `BotCommands::parse` fails when it cannot convert an empty string to `usize`. Changing
the variants to `String` makes the parse unconditionally succeed. All argument validation and type
conversion is then deferred to `parse_session_arg`, which provides clearer error messages than a
parse failure would.

**`parse_session_arg` triages arguments in one place** — The function provides a single, tested
decision point for the three cases (empty → keyboard, numeric → direct, invalid → hint). Both
`cmd_switch` and `cmd_delete` call it identically, eliminating duplicate branching logic.

**`do_switch` / `do_delete` extract shared logic** — Before SY-19, the switch/delete logic lived
entirely in `cmd_switch` / `cmd_delete`. Extracting it into `do_switch` / `do_delete` means the
callback handler shares the same validated path — there is no separate "callback version" of the
logic that could drift out of sync.

**Re-fetch session list on every `do_switch` / `do_delete` call** — Callbacks are asynchronous:
the user may tap a button seconds or minutes after the keyboard was displayed, during which sessions
may have been created or deleted. Re-fetching the session list from the database on every invocation
ensures the index is validated against the current state, not the stale keyboard-time snapshot.

**`answer_callback_query` called before DB operations** — Telegram displays a loading spinner on
the button until `answer_callback_query` is called. Calling it first (before any potentially slow
storage operations) ensures the spinner is dismissed promptly and the UI feels responsive.

**`edit_message_text` to remove keyboard after action** — Replacing the keyboard message with plain
text after executing the action prevents the user from tapping a button twice. Edit failures (e.g.,
message too old or already deleted) are logged at `warn` but not propagated — the action already
succeeded in storage by that point.

**Defensive guard after `filter_command` boundary** — Rather than relying solely on
`filter_command` to catch all slash prefixes, the guard in `handle_message` provides a second line
of defense. Any slash message that slips through (due to future enum additions, parse edge cases,
or bot group-chat interactions) gets a helpful hint instead of being forwarded to the LLM.

**No new crate dependencies** — `InlineKeyboardMarkup`, `CallbackQuery`, `InlineKeyboardButton`,
`SendMessageSetters`, and all other new types are already part of `teloxide 0.17`.

---

## Data Flow

```
Telegram Update
  |
  v
dptree::entry()
  |
  +--> Update::filter_message()
  |      |
  |      +--> filter_command::<Command>()
  |      |      |  Switch("") / Switch("3") / Switch("abc")
  |      |      |  Delete("") / Delete("3") / Delete("abc")
  |      |      |  Start / Help / New / History / List
  |      |      v
  |      |    commands::handle_command
  |      |      |  parse_session_arg(arg) -> Ok(None) | Ok(Some(n)) | Err(hint)
  |      |      |
  |      |      +--> Ok(None)   -> cmd_switch_keyboard / cmd_delete_keyboard
  |      |      |                    build_session_keyboard -> send InlineKeyboardMarkup
  |      |      |
  |      |      +--> Ok(Some(n)) -> do_switch(n, ...) / do_delete(n, ...)
  |      |      |                    re-fetch sessions from DB, validate, execute
  |      |      |
  |      |      +--> Err(hint)  -> bot.send_message(hint)
  |      |
  |      +--> fallback: handle_message
  |             |  text.starts_with('/') -> defensive guard (hint reply, return)
  |             |  regular text -> resolve_session -> agent.complete() -> send HTML
  |
  +--> Update::filter_callback_query()
         |  data = "switch:N" / "delete:N"
         v
       commands::handle_callback
         |  1. is_authorized check
         |  2. answer_callback_query (dismiss spinner)
         |  3. parse_callback_data("switch:N") -> ("switch", N)
         |  4. do_switch(N, ...) / do_delete(N, ...)
         |     re-fetch from DB, handle staleness
         |  5. edit_message_text (remove keyboard, show result)
```

---

## Files Changed

| File | Change |
|------|--------|
| `synapse-telegram/src/commands.rs` | `Switch(String)` / `Delete(String)` in enum; `Start` variant added; `parse_session_arg`; `fetch_chat_sessions`; `build_session_keyboard`; `cmd_switch_keyboard`; `cmd_delete_keyboard`; `do_switch`; `do_delete`; `parse_callback_data`; `pub handle_callback`; 14 required + 11 additional unit tests |
| `synapse-telegram/src/handlers.rs` | Defensive guard at line 83: `if text.starts_with('/') { ... return Ok(()); }` placed before LLM call |
| `synapse-telegram/src/main.rs` | Dispatcher restructured from `Update::filter_message()` only to `dptree::entry()` with two branches (message + callback query) |

## Files NOT Changed

- `synapse-core/` — All changes confined to `synapse-telegram`; hexagonal architecture preserved
- `synapse-cli/` — CLI is entirely unaffected
- `Cargo.toml` / `Cargo.lock` — No new dependencies; all new types from existing `teloxide 0.17`

---

## Risk Notes

Four low-severity risks from the QA report, all with existing mitigations:

- **R-1 (Stale keyboard index)**: `do_switch`/`do_delete` re-fetch the session list from the DB on
  every call. Out-of-bounds indexes return an error message via the message edit rather than
  crashing. Self-healing.

- **R-2 (`edit_message_text` failure)**: The callback action succeeds in storage before the edit
  attempt. Edit failures are logged at `warn` and not propagated. The keyboard message remains
  visible but no data is corrupted.

- **R-3 (`do_delete` auto-create failure)**: If `storage.create_session` fails after the last
  session is deleted, the user receives a misleading success message. The `sessions` vec is empty,
  and the next regular message triggers `resolve_session`'s slow path which correctly auto-creates
  a session. Self-recovering.

- **R-4 (`answer_callback_query` failure)**: Uses `?` — if the call fails (network error), the
  function returns early without executing the action. The Telegram spinner auto-dismisses after
  a few seconds. Minor UX impact; no data corruption.

None are blocking.

---

## Metrics

| Metric | Target | Achieved |
|--------|--------|----------|
| `cargo fmt --check` | Passes | Passes |
| `cargo clippy -- -D warnings` | Zero warnings | Zero warnings |
| `cargo test -p synapse-telegram` | All green | 68 passed, 0 failed |
| `Switch(String)` and `Delete(String)` in enum | Required | Both variants changed |
| `/switch` / `/delete` without args never forward to LLM | Required | Keyboard path via `parse_session_arg("") -> Ok(None)` |
| `/start` command implemented | Required | `Start` variant + `cmd_start` |
| Defensive guard in `handle_message` | Required | `text.starts_with('/')` guard before LLM call |
| Inline keyboard for `/switch` (no arg) | Required | `cmd_switch_keyboard` with `"switch:N"` callback data |
| Inline keyboard for `/delete` (no arg) | Required | `cmd_delete_keyboard` with `"delete:N"` callback data |
| `handle_callback` endpoint for `CallbackQuery` | Required | Registered in dispatcher |
| Callback executes action and removes keyboard | Required | `do_switch`/`do_delete` + `edit_message_text` |
| `answer_callback_query` before DB operations | Required | Line 626 — step 2 in handler |
| Authorization check in `handle_callback` | Required | `is_authorized` check; unauthorized = silent drop |
| Stale index handled via DB re-fetch | Required | `fetch_chat_sessions` called on every invocation |
| All existing commands continue to work | Required | 43 pre-existing tests unchanged |
| No new crate dependencies | Required | All types from existing `teloxide 0.17` |
| No changes to `synapse-core` | Required | Confirmed |
| 14 required unit tests from Task 7 | Required | All 14 present and passing |
