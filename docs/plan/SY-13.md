# SY-13 Plan: Telegram Bot (Phase 12)

Status: DRAFT

## Overview

Implement the Telegram bot interface for Synapse, proving that the hexagonal architecture allows multiple frontends to share the same `synapse-core` Agent, SessionStore, and MCP subsystems without duplicating business logic. The `synapse-telegram` crate (currently an empty placeholder from SY-1) is brought to life using `teloxide`, wired to the core Agent for LLM interactions, SessionStore for session-per-chat persistence, and MCP for tool usage. A single config struct addition to `synapse-core` is the only core change; all Telegram-specific logic lives in `synapse-telegram`.

## Components

### 1. TelegramConfig in synapse-core (`synapse-core/src/config.rs`)

The only modification to `synapse-core`. Add `TelegramConfig` struct and an optional `telegram` field to `Config`.

#### 1.1 TelegramConfig Struct

```rust
/// Telegram bot configuration.
#[derive(Debug, Clone, PartialEq, Deserialize)]
pub struct TelegramConfig {
    /// Bot token. Overridden by TELEGRAM_BOT_TOKEN env var.
    #[serde(default)]
    pub token: Option<String>,
    /// Telegram user IDs allowed to interact with the bot.
    /// Empty list = reject all users (secure by default).
    #[serde(default)]
    pub allowed_users: Vec<u64>,
}
```

**Requirement source:** `docs/phase/phase-12.md` (TelegramConfig struct), PRD constraint 2 ("TelegramConfig must live in `synapse-core/src/config.rs`").

#### 1.2 Config Struct Extension

Add `pub telegram: Option<TelegramConfig>` with `#[serde(default)]` to `Config`. Update `Config::default()` to set `telegram: None`.

#### 1.3 Default Implementation

```rust
impl Default for TelegramConfig {
    fn default() -> Self {
        Self {
            token: None,
            allowed_users: Vec::new(),
        }
    }
}
```

Secure default: empty `allowed_users` rejects all users.

**Requirement source:** PRD Scenario 3 (empty allowlist rejects all).

#### 1.4 lib.rs Export

Add `TelegramConfig` to the `pub use config::{...}` line in `synapse-core/src/lib.rs`.

#### 1.5 Tests

- `test_config_without_telegram_section` -- Config without `[telegram]` section has `telegram: None`.
- `test_config_with_telegram_section` -- Config with `[telegram]` section parses correctly.
- `test_config_telegram_partial_defaults` -- Config with only `token` set uses empty `allowed_users` default.
- `test_telegram_config_default` -- Default `TelegramConfig` has `token: None` and empty `allowed_users`.

### 2. synapse-telegram Dependencies (`synapse-telegram/Cargo.toml`)

Replace the placeholder comment with actual dependencies:

| Crate | Features | Purpose |
|-------|----------|---------|
| `synapse-core` | path = "../synapse-core" | Core library (Agent, Config, SessionStore, MCP) |
| `teloxide` | `macros` | Telegram Bot API framework |
| `tokio` | `rt-multi-thread`, `macros` | Async runtime |
| `anyhow` | -- | Application-level error handling (per conventions) |
| `futures` | -- | Stream utilities for agent stream consumption |
| `uuid` | `v4`, `v7` | UUID operations for session IDs |
| `tracing` | -- | Structured logging |
| `tracing-subscriber` | `env-filter` | Log output with level filtering |

**Requirement source:** PRD task 12.1, conventions.md (anyhow in interface crates).

### 3. Bot Initialization (`synapse-telegram/src/main.rs`)

Complete rewrite of the placeholder `main.rs` to a fully functional bot entry point.

#### 3.1 Entry Point

```rust
#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // 1. Initialize tracing
    // 2. Load config
    // 3. Resolve bot token
    // 4. Create Bot instance
    // 5. Create storage
    // 6. Run auto-cleanup
    // 7. Create provider
    // 8. Initialize MCP client
    // 9. Create Agent
    // 10. Rebuild chat-to-session map from existing sessions
    // 11. Set up Dispatcher with dependency injection
    // 12. Run Dispatcher (long-polling)
}
```

**Requirement source:** PRD task 12.2, Research Section 2.9 (CLI reference pattern).

#### 3.2 Bot Token Resolution

```rust
/// Resolve bot token with env var priority over config.
///
/// Priority:
/// 1. TELEGRAM_BOT_TOKEN environment variable
/// 2. telegram.token in config.toml
fn resolve_bot_token(config: &Config) -> anyhow::Result<String> {
    if let Ok(token) = std::env::var("TELEGRAM_BOT_TOKEN") {
        if !token.is_empty() {
            return Ok(token);
        }
    }
    config.telegram.as_ref()
        .and_then(|t| t.token.clone())
        .ok_or_else(|| anyhow::anyhow!(
            "Bot token required: set TELEGRAM_BOT_TOKEN env var \
             or telegram.token in config"
        ))
}
```

The resolved token is passed to `Bot::new(token)`. The token is never logged at any level.

**Requirement source:** `docs/phase/phase-12.md` (bot token resolution priority), PRD Scenario 5 and 6, conventions.md (no secrets in logs).

#### 3.3 Shared State Setup

All shared state is wrapped in `Arc` for `teloxide` Dispatcher dependency injection:

| Type | Purpose |
|------|---------|
| `Arc<Config>` | Read-only configuration (for authorization checks) |
| `Arc<Agent>` | LLM + MCP orchestrator |
| `Arc<Box<dyn SessionStore>>` | Session persistence |
| `Arc<RwLock<HashMap<i64, Uuid>>>` | Chat ID to session ID mapping (`ChatSessionMap`) |

```rust
type ChatSessionMap = Arc<tokio::sync::RwLock<HashMap<i64, Uuid>>>;
```

**Requirement source:** Research Section 4.3 (Arc wrapping), Research Section 4.2 (dptree deps).

#### 3.4 Dispatcher Setup

```rust
let handler = Update::filter_message()
    .filter(|msg: Message| msg.text().is_some())
    .endpoint(handle_message);

Dispatcher::builder(bot, handler)
    .dependencies(dptree::deps![config, agent, storage, chat_map])
    .enable_ctrlc_handler()
    .build()
    .dispatch()
    .await;
```

Uses long-polling mode (no webhook server needed per PRD assumptions).

**Requirement source:** Research Section 5.5 (long-polling), PRD assumption 4.

#### 3.5 Tracing Initialization

```rust
tracing_subscriber::fmt()
    .with_env_filter(
        tracing_subscriber::EnvFilter::from_default_env()
            .add_directive("synapse_telegram=info".parse()?)
    )
    .init();
```

**Requirement source:** conventions.md (logging), vision.md Section 10.

### 4. Message Handler (`synapse-telegram/src/handlers.rs`)

New file containing the message handler logic with authorization, session management, and agent invocation.

#### 4.1 Handler Signature

```rust
pub async fn handle_message(
    bot: Bot,
    msg: teloxide::types::Message,
    config: Arc<Config>,
    agent: Arc<Agent>,
    storage: Arc<Box<dyn SessionStore>>,
    chat_map: ChatSessionMap,
) -> ResponseResult<()>
```

The handler is the `endpoint` for `Update::filter_message()`. teloxide injects dependencies by type via `dptree`.

**Requirement source:** Research Section 4.2 (teloxide dispatcher pattern).

#### 4.2 User Authorization

The first check in the handler, before any session lookup or agent invocation:

```rust
let user_id = msg.from().map(|u| u.id.0).unwrap_or(0);
let allowed = config.telegram.as_ref()
    .map(|t| t.allowed_users.contains(&user_id))
    .unwrap_or(false);

if !allowed {
    return Ok(()); // Silent drop
}
```

Rules (per PRD):
- Check `msg.from().map(|u| u.id.0)` against `allowed_users` on every message.
- Empty `allowed_users` = reject all (secure by default).
- No `telegram` config section = reject all (secure by default).
- Silent drop: no reply, no error, no acknowledgment.

**Requirement source:** `docs/phase/phase-12.md` (user authorization), PRD Scenarios 2, 3.

#### 4.3 Session-per-Chat Lookup and Creation

After authorization passes, resolve or create a session for this chat:

```rust
let chat_id = msg.chat.id.0;

// Try to find existing session
let session_id = {
    let map = chat_map.read().await;
    map.get(&chat_id).copied()
};

let session_id = match session_id {
    Some(id) => {
        storage.touch_session(id).await.ok();
        id
    }
    None => {
        // Create new session
        let session = Session::new(&config.provider, &config.model)
            .with_name(format!("tg:{}", chat_id));
        storage.create_session(&session).await?;
        let mut map = chat_map.write().await;
        // Double-check after acquiring write lock
        if let Some(&existing_id) = map.get(&chat_id) {
            existing_id
        } else {
            map.insert(chat_id, session.id);
            session.id
        }
    }
};
```

Session naming convention: `"tg:<chat_id>"` (e.g., `"tg:123456789"`).

**Requirement source:** PRD task 12.4, Research Section 6 (session-per-chat design).

#### 4.4 Chat Map Reconstruction on Startup

On startup (in `main.rs`), rebuild the in-memory map from existing sessions:

```rust
async fn rebuild_chat_map(
    storage: &dyn SessionStore,
) -> HashMap<i64, Uuid> {
    let sessions = storage.list_sessions().await.unwrap_or_default();
    sessions.iter()
        .filter_map(|s| {
            s.name.as_ref()
                .and_then(|n| n.strip_prefix("tg:"))
                .and_then(|id| id.parse::<i64>().ok())
                .map(|chat_id| (chat_id, s.id))
        })
        .collect()
}
```

**Requirement source:** Research Section 6.2 (reconstruction on startup), PRD Scenario 4 (persistence across restarts).

#### 4.5 Message Processing Flow

After resolving the session:

1. Extract text from the Telegram message (`msg.text()`).
2. Load conversation history from storage (`storage.get_messages(session_id)`).
3. Build `Vec<Message>` from history.
4. Append new user message.
5. Store user message in database.
6. Send typing indicator (`bot.send_chat_action(chat_id, ChatAction::Typing)`).
7. Call `agent.complete(&mut messages)` to get the full response (including tool call handling).
8. Store assistant response in database.
9. Chunk the response if it exceeds 4096 characters.
10. Send response message(s) to the Telegram chat.

**Requirement source:** PRD task 12.3, PRD Scenarios 1, 4, 7.

#### 4.6 Using `agent.complete()` (Not `stream_owned()`)

The handler uses `agent.complete()` rather than streaming because:
- Telegram messages are sent atomically (no incremental display).
- `complete()` handles the tool call loop internally and returns the final text.
- Simpler implementation with no stream consumption overhead.

**Requirement source:** Research Section 9.8, Research T1.

#### 4.7 Message Chunking

Telegram's `sendMessage` API has a 4096-character limit. Long responses must be split:

```rust
const TELEGRAM_MSG_LIMIT: usize = 4096;

fn chunk_message(text: &str) -> Vec<&str> {
    if text.len() <= TELEGRAM_MSG_LIMIT {
        return vec![text];
    }
    // Split at paragraph/newline/space boundaries
    // without exceeding TELEGRAM_MSG_LIMIT per chunk
    // ...
}
```

Each chunk is sent as a separate `bot.send_message()` call.

**Requirement source:** PRD Risk (long responses exceeding 4096 chars).

#### 4.8 Error Handling in Handler

Agent errors are logged via `tracing::error!` and a user-friendly error message is sent to the chat:

```rust
match agent.complete(&mut messages).await {
    Ok(response) => { /* send response */ }
    Err(e) => {
        tracing::error!("Agent error for chat {}: {}", chat_id, e);
        bot.send_message(
            msg.chat.id,
            "Sorry, I encountered an error. Please try again.",
        ).await?;
    }
}
```

**Requirement source:** Research T5 (error handling in Telegram), conventions.md (no silent failures).

### 5. config.example.toml Update

Add `[telegram]` section to the example config:

```toml
# Telegram bot configuration
# [telegram]
# Bot token (can also be set via TELEGRAM_BOT_TOKEN env var, which takes priority)
# WARNING: Never commit your bot token! Use the env var for production.
# token = "123456:ABC-DEF1234ghIkl-zyx57W2v1u123ew11"
#
# Telegram user IDs allowed to interact with the bot
# Empty list = reject all users (secure by default)
# Find your user ID by messaging @userinfobot on Telegram
# allowed_users = [123456789, 987654321]
```

**Requirement source:** Research D7 (config.example.toml missing telegram section).

### 6. Graceful Shutdown

The `enable_ctrlc_handler()` on the Dispatcher handles Ctrl+C. For Agent shutdown:

```rust
// After dispatcher stops
if let Ok(agent) = Arc::try_unwrap(agent) {
    agent.shutdown().await;
} else {
    tracing::warn!("Could not unwrap Agent for graceful shutdown");
}
```

If `Arc::try_unwrap()` fails (other references still held), MCP connections are dropped when the process exits. This is acceptable for the initial implementation.

**Requirement source:** Research Section 9.2 (Agent lifetime and Arc).

## API Contract

### External: Telegram Bot API

The bot communicates with Telegram via `teloxide` (long-polling mode):
- **Inbound:** `Update` objects containing `Message` with text
- **Outbound:** `sendMessage` with text response, `sendChatAction` with typing indicator

### Internal: synapse-core Usage

The Telegram bot uses the same public API as the CLI:

```rust
// Config
let config = Config::load().unwrap_or_default();

// Storage
let storage = create_storage(db_url).await?;

// Provider
let provider = create_provider(&config)?;

// MCP
let mcp_client = init_mcp_client(mcp_path).await;

// Agent
let agent = Agent::new(provider, mcp_client);

// Message processing
let response = agent.complete(&mut messages).await?;
```

No new core methods or traits are needed. This validates the hexagonal architecture.

### Internal: Config TOML

```toml
[telegram]
token = "bot123:ABC"
allowed_users = [123456789, 987654321]
```

## Data Flows

### Flow 1: Authorized User Sends Message (No Existing Session)

```
1. Telegram API delivers Update with Message from user 123456789
2. teloxide Dispatcher invokes handle_message() with injected deps
3. Handler checks: user 123456789 in allowed_users? -> Yes
4. Handler checks chat_map: session for chat_id? -> No
5. Handler creates Session("tg:<chat_id>"), stores in DB, inserts into chat_map
6. Handler loads history (empty for new session)
7. Handler creates Message(Role::User, text), stores in DB
8. Handler sends ChatAction::Typing
9. Handler calls agent.complete(&mut messages)
10. Agent handles tool calls internally, returns final text Message
11. Handler stores Message(Role::Assistant, response) in DB
12. Handler chunks response if > 4096 chars
13. Handler sends bot.send_message(chat_id, chunk) for each chunk
14. Handler returns Ok(())
```

### Flow 2: Authorized User Sends Follow-up (Existing Session)

```
1. Telegram API delivers Update with Message from user 123456789
2. Handler checks authorization -> allowed
3. Handler checks chat_map: session for chat_id? -> Yes (UUID found)
4. Handler loads history from DB (previous messages)
5. Handler appends new user message, stores in DB
6. Handler calls agent.complete() with full conversation context
7. Handler stores response, sends to Telegram
```

### Flow 3: Unauthorized User Sends Message

```
1. Telegram API delivers Update with Message from user 999999999
2. Handler checks: user 999999999 in allowed_users? -> No
3. Handler returns Ok(()) immediately -- silent drop
4. No reply, no error, no acknowledgment
```

### Flow 4: Empty Allowlist

```
1. Config has allowed_users = []
2. Any user sends a message
3. Handler checks: user ID in []? -> No (always false)
4. Silent drop for all users
```

### Flow 5: Bot Startup with Env Var Token

```
1. TELEGRAM_BOT_TOKEN=bot123:ABC is set
2. resolve_bot_token() checks env var -> found, non-empty
3. Bot::new("bot123:ABC") created
4. Config file token ignored
```

### Flow 6: Bot Startup without Token

```
1. No TELEGRAM_BOT_TOKEN env var
2. No telegram.token in config
3. resolve_bot_token() returns Err
4. main() exits with error: "Bot token required: ..."
```

### Flow 7: MCP Tool Usage via Telegram

```
1. Authorized user sends "What's the weather in London?"
2. Handler loads session, builds messages, calls agent.complete()
3. Agent calls provider.complete_with_tools(messages, tools)
4. Provider returns tool_call: get_weather({location: "London"})
5. Agent executes tool via MCP client
6. Agent appends tool result, calls provider again
7. Provider returns final text: "The weather in London is sunny, 22C"
8. Handler receives final text, stores and sends to Telegram
```

## Non-Functional Requirements

1. **Zero core logic duplication:** All LLM interaction, tool calling, and session management is handled by `synapse-core`. The Telegram crate contains only interface-specific code (authorization, message routing, Telegram API interaction).

2. **Backward compatibility:** The `TelegramConfig` addition to `Config` is optional (`Option<TelegramConfig>` with `#[serde(default)]`). Existing config files without a `[telegram]` section continue to work. All existing tests pass without modification.

3. **Security:**
   - Bot token never logged at any level.
   - Secure-by-default: empty `allowed_users` rejects all users.
   - Silent drop for unauthorized users (does not reveal bot existence).

4. **Error handling:** `synapse-telegram` uses `anyhow` for application errors (consistent with `synapse-cli`). Handler errors are logged and a generic user-friendly message is sent.

5. **Concurrency:** Multiple chats handled concurrently. `RwLock` protects the chat-to-session map. SQLite WAL mode handles concurrent database writes. Agent methods use `&self` (safe behind `Arc`).

6. **Performance:** Typing indicator sent before LLM call to signal activity. Long-polling mode avoids webhook server overhead.

7. **Module conventions:** No `mod.rs` files. New module system (Rust 2018+). `handlers.rs` is a sibling of `main.rs` with `mod handlers;` declaration.

8. **No unwrap/expect in synapse-core:** The single core change (config struct) uses only `#[serde(default)]` -- no unwrap/expect.

## Risks and Mitigations

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| `teloxide` incompatibility with nightly Rust | Low | High | Pin `teloxide` to 0.17. Test during implementation. The crate supports nightly. |
| Telegram 4096-char message limit | Medium | Medium | Implement `chunk_message()` helper that splits at paragraph/newline/space boundaries. |
| `Agent::shutdown(self)` takes ownership vs `Arc<Agent>` | Certain | Low | Use `Arc::try_unwrap()` after Dispatcher stops. Fallback: process exit drops connections (acceptable). |
| Concurrent session creation for same chat_id | Low | Medium | Double-check in write lock after acquire (check-then-create pattern). |
| Telegram rate limits (~30 msg/s, 1 msg/s/chat) | Low | Low | For initial implementation, no explicit rate limiting. Multiple chunks include a small delay. `teloxide::Throttle` adaptor available for future use. |
| Bot token accidentally logged | Low | High | Token passed directly to `Bot::new()`. Never passed to `tracing` macros. Masked in any debug output. |

## Deviations to Fix

All deviations from the research document are addressed:

| # | Deviation | Component |
|---|-----------|-----------|
| D1 | No `TelegramConfig` in `Config` | Component 1 (1.1, 1.2) |
| D2 | `synapse-telegram` has no dependencies | Component 2 |
| D3 | `synapse-telegram/src/main.rs` is synchronous | Component 3 |
| D4 | No message handler | Component 4 |
| D5 | No session-per-chat persistence | Component 4 (4.3, 4.4) |
| D6 | No user authorization | Component 4 (4.2) |
| D7 | `config.example.toml` missing `[telegram]` section | Component 5 |

D1 is the only change to `synapse-core`; all others are within `synapse-telegram`.

## Testing Strategy

### Unit Tests (synapse-core)

**Config tests** (Component 1.5): 4 tests
- `test_config_without_telegram_section`
- `test_config_with_telegram_section`
- `test_config_telegram_partial_defaults`
- `test_telegram_config_default`

### Unit Tests (synapse-telegram)

**Authorization tests:**
- `test_is_authorized_user_in_list` -- User in `allowed_users` returns true.
- `test_is_authorized_user_not_in_list` -- User not in list returns false.
- `test_is_authorized_empty_list` -- Empty list rejects all users.

**Token resolution tests:**
- `test_resolve_token_env_var` -- Env var takes priority over config.
- `test_resolve_token_config` -- Config used when no env var.
- `test_resolve_token_none` -- Error when neither is set.
- `test_resolve_token_empty_env_var` -- Empty env var falls through to config.

**Message chunking tests:**
- `test_chunk_short_message` -- Message under 4096 chars returns single chunk.
- `test_chunk_long_message` -- Message over 4096 chars split correctly.
- `test_chunk_at_boundary` -- Split at paragraph/newline boundaries.

**Chat map reconstruction tests:**
- `test_rebuild_chat_map_empty` -- No sessions produces empty map.
- `test_rebuild_chat_map_with_telegram_sessions` -- Sessions with `tg:` prefix parsed correctly.
- `test_rebuild_chat_map_ignores_non_telegram` -- Sessions without `tg:` prefix ignored.

**Total: ~12 new unit tests in synapse-telegram, 4 in synapse-core.**

### Integration Tests

Full integration testing requires a running Telegram bot (not feasible in CI). Manual testing:
- Send message to bot, verify LLM response received.
- Verify unauthorized user messages are silently dropped.
- Restart bot, send follow-up message, verify session continuity.

### Regression

All existing `cargo test` must pass. The `TelegramConfig` addition is backward-compatible (optional, serde-defaulted). No existing code is modified except adding one optional field and struct.

## File Changes Summary

| File | Change Type | Description |
|------|-------------|-------------|
| `synapse-core/src/config.rs` | Modify | Add `TelegramConfig` struct, add `pub telegram: Option<TelegramConfig>` to `Config`, add `Default` impl, add tests |
| `synapse-core/src/lib.rs` | Modify | Export `TelegramConfig` |
| `synapse-telegram/Cargo.toml` | Modify | Add all required dependencies |
| `synapse-telegram/src/main.rs` | Rewrite | Bot entry point: config loading, token resolution, shared state setup, Dispatcher |
| `synapse-telegram/src/handlers.rs` | **Create** | Message handler: authorization, session management, agent invocation, chunking, response sending |
| `config.example.toml` | Modify | Add `[telegram]` section with commented examples |

### Files NOT modified (confirming PRD constraint 1):

- `synapse-core/src/agent.rs` -- no changes
- `synapse-core/src/provider.rs` -- no changes
- `synapse-core/src/storage.rs` -- no changes
- `synapse-core/src/mcp.rs` -- no changes
- `synapse-core/src/message.rs` -- no changes
- `synapse-core/src/session.rs` -- no changes
- `synapse-cli/` -- no changes

## Open Questions

None. All technical specifications are clearly defined in the PRD and phase-12.md. The research document resolved all technical questions (T1-T6):

| # | Question | Resolution |
|---|----------|------------|
| T1 | `complete()` vs `stream_owned()` for Telegram? | `complete()` -- Telegram messages are atomic, not streamed. Simpler, more appropriate. |
| T2 | Chat-to-session persistence strategy? | Session name convention (`"tg:<chat_id>"`), in-memory `HashMap` rebuilt on startup from `list_sessions()`. |
| T3 | `Agent::shutdown()` with `Arc`? | `Arc::try_unwrap()` after Dispatcher stops. Fallback: process exit handles cleanup. |
| T4 | Typing indicator before LLM calls? | Yes, `bot.send_chat_action(ChatAction::Typing)` before `agent.complete()`. |
| T5 | Error handling in Telegram handler? | Log via `tracing::error!`, send generic user-friendly message. |
| T6 | `TelegramConfig` derive `Default`? | Yes, with `token: None`, `allowed_users: vec![]`. Secure default. |
