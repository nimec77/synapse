# SY-16 Implementation Plan: Phase 15 -- Code Refactoring

Status: PLAN_APPROVED

## Overview

Improve internal code quality without changing external behaviour. Seven tasks in strict dependency order eliminate dead code, reduce ~400 lines of duplication, replace magic strings, add structured tracing, extract shared utilities, split large files, and tighten the public API surface.

**Zero external behaviour changes.** Pre-commit gate (`cargo fmt --check && cargo clippy -- -D warnings && cargo test`) after every task.

---

## Components

### 1. Dead Code Removal (Task 15.1)

**Files modified:**
- `synapse-core/src/lib.rs` -- delete `placeholder` module (lines 25-31)
- `synapse-core/src/provider/streaming.rs` -- remove `ToolCall`, `ToolResult`, `Error` variants and their tests
- `synapse-cli/src/main.rs` -- remove `StreamEvent::Error(e)` arm (line 213) and `Some(Ok(_))` wildcard arm (line 216)
- `synapse-cli/src/repl.rs` -- remove `StreamEvent::Error(e)` arm (line 646)
- `synapse-core/src/provider/deepseek.rs` -- add serde-justification comment on `finish_reason` `#[allow(dead_code)]`
- `synapse-core/src/provider/openai.rs` -- add serde-justification comment on `finish_reason` `#[allow(dead_code)]`

**After removal, `StreamEvent` has only:**
```rust
pub enum StreamEvent {
    TextDelta(String),
    Done,
}
```

**CLI match simplification:**
```rust
// Before (main.rs):
Some(Ok(StreamEvent::Error(e))) => { return Err(e).context("Streaming error"); }
Some(Ok(_)) => { /* Ignore ToolCall/ToolResult */ }

// After:
// Both arms removed. Only TextDelta, Done, Err remain.
```

**Impact on `streaming.rs` use in `provider.rs`:** The `use crate::provider::ProviderError` import in `streaming.rs` becomes unused after removing `Error(ProviderError)`. Remove it.

### 2. OpenAI-Compatible Provider Extraction (Task 15.2)

**New file:** `synapse-core/src/provider/openai_compat.rs`

**Module declaration:** Add `mod openai_compat;` to `synapse-core/src/provider.rs`.

**Shared serde types moved (all `pub(super)`):**
- `ApiMessage`
- `ApiRequest`
- `StreamingApiRequest`
- `OaiTool` (unified from `DeepSeekTool`/`OpenAiTool`)
- `OaiFunction` (unified from `DeepSeekFunction`/`OpenAiFunction`)
- `OaiToolCall` (unified from `DeepSeekToolCall`/`OpenAiToolCall`)
- `OaiToolCallFunction` (unified from `DeepSeekToolCallFunction`/`OpenAiToolCallFunction`)
- `ApiResponse`
- `Choice`
- `ChoiceMessage`
- `ApiError`
- `ErrorDetail`
- `StreamChunk`
- `StreamChoice` (with serde-justified `#[allow(dead_code)]` on `finish_reason`)
- `StreamDelta`

**Shared functions moved:**
- `pub(super) fn build_api_messages(messages: &[Message]) -> Vec<ApiMessage>`
- `pub(super) async fn complete_request(client: &reqwest::Client, endpoint: &str, api_key: &str, request: &ApiRequest) -> Result<Message, ProviderError>`
- `pub(super) fn to_oai_tools(tools: &[ToolDefinition]) -> Option<Vec<OaiTool>>`
- `pub(super) fn stream_sse(client: reqwest::Client, endpoint: &str, api_key: String, model: String, messages: Vec<Message>, max_tokens: u32) -> Pin<Box<dyn Stream<Item = Result<StreamEvent, ProviderError>> + Send>>`

**Constant:** `pub(super) const SSE_DONE_MARKER: &str = "[DONE]";` (addresses task 15.3 partially)

**Constant:** `pub(super) const DEFAULT_MAX_TOKENS: u32 = 1024;`

**Reduced `deepseek.rs` (~50-80 lines):**
```rust
use super::openai_compat;
use super::{LlmProvider, ProviderError, StreamEvent};

const API_ENDPOINT: &str = "https://api.deepseek.com/chat/completions";

pub struct DeepSeekProvider {
    client: reqwest::Client,
    api_key: String,
    model: String,
}

impl DeepSeekProvider {
    pub fn new(api_key: impl Into<String>, model: impl Into<String>) -> Self { ... }
}

#[async_trait]
impl LlmProvider for DeepSeekProvider {
    async fn complete(&self, messages: &[Message]) -> Result<Message, ProviderError> {
        let api_messages = openai_compat::build_api_messages(messages);
        let request = openai_compat::ApiRequest { model: self.model.clone(), messages: api_messages, max_tokens: openai_compat::DEFAULT_MAX_TOKENS, tools: None };
        openai_compat::complete_request(&self.client, API_ENDPOINT, &self.api_key, &request).await
    }

    async fn complete_with_tools(&self, messages: &[Message], tools: &[ToolDefinition]) -> Result<Message, ProviderError> {
        let api_messages = openai_compat::build_api_messages(messages);
        let request = openai_compat::ApiRequest { model: self.model.clone(), messages: api_messages, max_tokens: openai_compat::DEFAULT_MAX_TOKENS, tools: openai_compat::to_oai_tools(tools) };
        openai_compat::complete_request(&self.client, API_ENDPOINT, &self.api_key, &request).await
    }

    fn stream(&self, messages: &[Message]) -> Pin<Box<dyn Stream<...> + Send + '_>> {
        openai_compat::stream_sse(self.client.clone(), API_ENDPOINT, self.api_key.clone(), self.model.clone(), messages.to_vec(), openai_compat::DEFAULT_MAX_TOKENS)
    }
}
```

**Reduced `openai.rs`:** Identical pattern, only `API_ENDPOINT` differs.

**Test migration:**
- Move serde tests to `openai_compat.rs` (test once, not twice).
- Keep provider-specific tests only for `new()` / struct wiring.
- Verify byte-identical JSON output pre/post extraction.

### 3. Constants and Methods (Task 15.3)

**`Role::as_str()` and `FromStr`** in `synapse-core/src/message.rs`:
```rust
impl Role {
    pub fn as_str(&self) -> &'static str {
        match self {
            Role::System => "system",
            Role::User => "user",
            Role::Assistant => "assistant",
            Role::Tool => "tool",
        }
    }
}

impl std::str::FromStr for Role {
    type Err = String;
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "system" => Ok(Role::System),
            "user" => Ok(Role::User),
            "assistant" => Ok(Role::Assistant),
            "tool" => Ok(Role::Tool),
            other => Err(format!("unknown role: {}", other)),
        }
    }
}
```

**Replacements:**
- `openai_compat.rs` `build_api_messages()`: replace manual match with `m.role.as_str().to_string()`
- `sqlite.rs` `role_to_string()`: delegate to `role.as_str()`
- `sqlite.rs` `parse_role()`: delegate to `s.parse::<Role>().map_err(|e| StorageError::InvalidData(e))`

**Other constants:**
- `openai_compat.rs`: `SSE_DONE_MARKER` (already added in 15.2)
- `synapse-telegram/src/handlers.rs`: `const ERROR_REPLY: &str = "Sorry, I encountered an error. Please try again.";` -- replace both literal occurrences (lines 69, 123)
- `synapse-telegram/src/main.rs`: `const DEFAULT_TRACING_DIRECTIVE: &str = "synapse_telegram=info";` -- replace three occurrences (lines 42, 75, 95)
- `synapse-core/src/provider/factory.rs`: Add `const DEEPSEEK_API_KEY_ENV: &str = "DEEPSEEK_API_KEY";`, `const ANTHROPIC_API_KEY_ENV: &str = "ANTHROPIC_API_KEY";`, `const OPENAI_API_KEY_ENV: &str = "OPENAI_API_KEY";` -- replace three hard-coded occurrences in `get_api_key()`

### 4. Structured Tracing (Task 15.4)

**Dependency additions:**
```toml
# synapse-core/Cargo.toml
tracing = "0.1"

# synapse-cli/Cargo.toml
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }
```

**CLI tracing init** -- add to `main()` before any work:
```rust
tracing_subscriber::fmt()
    .with_env_filter(tracing_subscriber::EnvFilter::from_default_env())
    .init();
```

**Instrumentation points (all at debug/info level, never logging secrets):**

| Location | Level | Content |
|----------|-------|---------|
| `agent.rs` `complete()` | `debug!` | Tool call iteration count, tool names being called |
| `openai_compat.rs` `complete_request()` | `debug!` | HTTP POST to endpoint (no auth header), status code |
| `openai_compat.rs` `stream_sse()` | `debug!` | Stream started/ended for endpoint |
| `anthropic.rs` `complete()`/`stream()` | `debug!` | HTTP POST to endpoint, status code |
| `factory.rs` `create_provider()` | `info!` | Provider and model selected |
| `sqlite.rs` various CRUD methods | `debug!` | Session created/retrieved/deleted, message added |
| `config.rs` `load()` | `debug!` | Resolved config path |
| `mcp/tools.rs` `McpClient::new()` | `info!` | Server connection success, tool count discovered |
| `mcp/tools.rs` `call_tool()` | `debug!` | Tool name being called |

**`eprintln!` replacements:**

| File | Current | Replacement |
|------|---------|-------------|
| `synapse-core/src/mcp/tools.rs` line 57 | `eprintln!("Warning: MCP server '{}' failed to start: {}", ...)` | `tracing::warn!("MCP server '{}' failed to start: {}", ...)` |
| `synapse-cli/src/main.rs` line 74 | `eprintln!("Warning: MCP initialization failed: {}", e)` | `tracing::warn!("MCP initialization failed: {}", e)` |
| `synapse-cli/src/main.rs` line 80 | `eprintln!("Warning: MCP config error: {}", e)` | `tracing::warn!("MCP config error: {}", e)` |
| `synapse-cli/src/repl.rs` line 675 | `eprintln!("Session: {}", session.id)` | `tracing::info!("Session: {}", session.id)` |

**Note:** `synapse-telegram/src/main.rs` `eprintln!` calls on lines 35, 54, 106 fire BEFORE tracing is initialized. They MUST remain as `eprintln!`.

### 5. Shared Utility Extraction (Task 15.5)

**`init_mcp_client()` moved to `synapse-core/src/mcp.rs`:**
```rust
/// Initialize an MCP client from config, returning None on any error.
///
/// Uses `tracing::warn!` for connection/config failures.
pub async fn init_mcp_client(config_path: Option<&str>) -> Option<McpClient> {
    match load_mcp_config(config_path) {
        Ok(Some(config)) => match McpClient::new(&config).await {
            Ok(client) if client.has_tools() => Some(client),
            Ok(_) => None,
            Err(e) => {
                tracing::warn!("MCP initialization failed: {}", e);
                None
            }
        },
        Ok(None) => None,
        Err(e) => {
            tracing::warn!("MCP config error: {}", e);
            None
        }
    }
}
```

**Re-export:** Add `init_mcp_client` to the `pub use mcp::...` line in `lib.rs` (or consumer crates use `synapse_core::mcp::init_mcp_client`).

**Update call sites:** Remove the `init_mcp_client()` function from:
- `synapse-cli/src/main.rs` (lines 68-84)
- `synapse-telegram/src/main.rs` (lines 208-224)

Both replaced with `synapse_core::mcp::init_mcp_client(...)` (or re-exported from `lib.rs`).

**`Agent::from_config()` factory method** in `synapse-core/src/agent.rs`:
```rust
impl Agent {
    /// Create an Agent from application config and optional MCP client.
    ///
    /// Encapsulates provider creation and system prompt wiring.
    pub fn from_config(
        config: &Config,
        mcp_client: Option<McpClient>,
    ) -> Result<Self, ProviderError> {
        let provider = create_provider(config)?;
        let mut agent = Self::new(provider, mcp_client);
        if let Some(ref prompt) = config.system_prompt {
            agent = agent.with_system_prompt(prompt);
        }
        Ok(agent)
    }
}
```

**Imports needed in `agent.rs`:** `use crate::config::Config;` and `use crate::provider::{create_provider, ProviderError};` (already partially imported).

**Update call sites:**
- `synapse-cli/src/main.rs` lines 184-190 (one-shot mode): replace with `let agent = Agent::from_config(&config, mcp_client).context("Failed to create agent")?;`
- `synapse-telegram/src/main.rs` lines 151-164: replace with `let agent = Agent::from_config(&config, mcp_client).context("Failed to create agent")?;`
- `synapse-cli/src/repl.rs`: evaluate if the REPL call site can also use `from_config` (it receives `provider` separately from `main.rs`; may need signature adjustment)

### 6. File Splitting (Task 15.6)

**`repl.rs` split into submodules (Rust 2018+ convention, no `mod.rs`):**

```
synapse-cli/src/
    repl.rs           -- module declarations, TerminalGuard, run_repl(), re-exports
    repl/
        app.rs        -- ReplApp struct, state fields, state transitions, helper methods
        render.rs     -- draw_*() and render_*() functions, TUI layout
        input.rs      -- handle_key_event(), key bindings
```

**Module file `synapse-cli/src/repl.rs` contains:**
```rust
mod app;
mod input;
mod render;

use app::ReplApp;
// ... TerminalGuard struct and run_repl() function ...
```

**Visibility:** Submodule items use `pub(super)` or `pub(crate)` as needed. Only `run_repl()` is public to `main.rs`.

**`commands.rs` extraction from `main.rs`:**

**New file:** `synapse-cli/src/commands.rs`

**Contents moved:**
- `Commands` enum (lines 42-49)
- `SessionAction` enum (lines 51-65)
- `handle_command()` function (lines 250-349)
- `truncate()` helper (lines 351-360)

**`main.rs` changes:**
- Add `mod commands;` declaration
- Add `use commands::{Commands, handle_command};`
- Remove the moved items

### 7. API Surface and Async Fix (Task 15.7)

**Narrowed `lib.rs` re-exports (keep only items actually imported via re-export by consumer crates):**

```rust
pub use agent::{Agent, AgentError};
pub use config::{Config, TelegramConfig};
pub use mcp::{McpClient, load_mcp_config, init_mcp_client};
pub use message::{Message, Role};
pub use provider::{LlmProvider, StreamEvent, create_provider};
pub use session::{Session, SessionSummary, StoredMessage};
pub use storage::{SessionStore, create_storage};
```

**Items removed from re-export (17 items):**
1. `ConfigError`
2. `LoggingConfig`
3. `McpSettings`
4. `SessionConfig`
5. `McpConfig`
6. `McpError`
7. `McpServerConfig`
8. `ToolDefinition`
9. `ToolCallData`
10. `AnthropicProvider`
11. `DeepSeekProvider`
12. `MockProvider`
13. `OpenAiProvider`
14. `ProviderError`
15. `CleanupResult`
16. `SqliteStore`
17. `StorageError`

These remain accessible via path imports (e.g., `synapse_core::storage::StorageError`) since modules remain `pub`.

**Async fix in `sqlite.rs`:**
```rust
// Before (line 62):
std::fs::create_dir_all(parent).map_err(|e| ...)?;

// After:
tokio::fs::create_dir_all(parent).await.map_err(|e| ...)?;
```

**Dependency change in `synapse-core/Cargo.toml`:**
```toml
tokio = { version = "1", features = ["rt", "macros", "process", "fs"] }
```

---

## API Contract

No external API changes. All modifications are internal. Consumer crates (`synapse-cli`, `synapse-telegram`) continue importing from `synapse_core` with the same public interface. Items removed from `lib.rs` re-exports are still accessible via their original module paths.

**New public additions:**
- `Role::as_str(&self) -> &'static str`
- `impl FromStr for Role`
- `Agent::from_config(config: &Config, mcp_client: Option<McpClient>) -> Result<Self, ProviderError>`
- `synapse_core::mcp::init_mcp_client(config_path: Option<&str>) -> Option<McpClient>`

---

## Data Flows

No data flow changes. All database schemas, API wire formats, message types, and session structures remain identical.

---

## Non-Functional Requirements

| NFR | Implementation |
|-----|----------------|
| Zero blocking I/O in async | Replace `std::fs::create_dir_all()` with `tokio::fs::create_dir_all().await` in `sqlite.rs` |
| Structured observability | `tracing` crate in `synapse-core` and `synapse-cli`; instrument agent, providers, storage, config, MCP |
| No secrets in logs | Never log API keys, tokens; tracing only logs operation metadata |
| Pre-commit gate | `cargo fmt --check && cargo clippy -- -D warnings && cargo test` after every task |
| No `mod.rs` files | `repl.rs` + `repl/` directory uses Rust 2018+ convention |
| No `unwrap()`/`expect()` in `synapse-core` | All new code uses `?` propagation |

---

## Risks

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| OpenAI-compat extraction changes JSON serialization | Medium | High | Run existing serde tests against shared types; verify byte-identical JSON output pre/post extraction |
| Removing re-exports breaks consumer crates | Medium | Medium | Audit actual imports (research doc section 7.2 already done); verify all crates compile after each removal |
| `repl.rs` split breaks TUI state machine | Low | Medium | Extract one submodule at a time; verify `cargo build` after each |
| `tracing` subscriber init in CLI captures output | Low | Low | Use `EnvFilter::from_default_env()` so tracing is silent by default unless `RUST_LOG` is set |
| `Agent::from_config()` couples Agent to Config+factory | Low | Low | Both are already in `synapse-core`; this is internal coupling, not cross-crate |

---

## Deviations to Fix

None. Research document (section 9) confirms all PRD requirements match the current codebase. The two minor estimate discrepancies (re-export count: 33 actual vs. ~24 PRD estimate; items to remove: 17 actual vs. ~16 PRD estimate) are corrected in this plan.

---

## Task Dependencies and Ordering

```
15.1 (dead code) --> 15.2 (OpenAI-compat extraction) --> 15.3 (constants)
                                                     \-> 15.4 (tracing) --> 15.5 (shared utilities)
                                                                       \-> 15.6 (file splitting)
                                                                       \-> 15.7 (API surface + async)
```

**Strict order:** 15.1 -> 15.2 -> 15.3 -> 15.4 -> 15.5 -> 15.6 -> 15.7

**Rationale:**
- 15.1 before 15.2: Remove dead variants before extracting shared module (avoid carrying dead code into new module)
- 15.2 before 15.3: `SSE_DONE_MARKER` goes into `openai_compat.rs`, and `Role::as_str()` is used in `build_api_messages()` which lives in the extracted module
- 15.2 before 15.4: Instrumentation targets the extracted module
- 15.4 before 15.5: `init_mcp_client()` in core uses `tracing::warn!` (requires `tracing` dependency added in 15.4)
- 15.6 and 15.7 last: Earlier tasks may move code; splitting after stabilization avoids rework

---

## Open Questions

None. All specifications are clear and validated against the codebase.
