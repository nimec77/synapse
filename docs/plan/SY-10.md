# SY-10 Plan: CLI REPL (Phase 9)

Status: PLAN_APPROVED

## Overview

Implement an interactive REPL mode for the Synapse CLI using `ratatui` + `crossterm`, supporting multi-turn conversations with streaming responses and session persistence.

## Components

### 1. Dependencies (Task 9.1)

Add to `synapse-cli/Cargo.toml`:
- `ratatui` — TUI framework (with default crossterm backend)
- `crossterm` — terminal handling (with `event-stream` feature for async event reading)

`ratatui` re-exports crossterm via `ratatui::crossterm`, but we need the `event-stream` feature on crossterm directly for `EventStream` (async compatible key event stream).

### 2. REPL Module (`synapse-cli/src/repl.rs`) (Task 9.2)

New file: `synapse-cli/src/repl.rs`

Declared from `main.rs` via `mod repl;`. Contains all REPL logic:

#### 2.1 Terminal Guard (Cleanup Safety)

```rust
struct TerminalGuard;
```

- On creation: `enable_raw_mode()`, `execute!(stdout, EnterAlternateScreen)`
- `Drop` impl: `disable_raw_mode()`, `execute!(stdout, LeaveAlternateScreen)`
- Guarantees terminal restoration on normal exit, error, or panic

#### 2.2 App State

```rust
struct ReplApp {
    messages: Vec<(Role, String)>,     // conversation history for display
    input: String,                      // current input buffer
    cursor_position: usize,             // cursor position in input
    scroll_offset: u16,                 // scroll position for history
    is_streaming: bool,                 // whether LLM is currently responding
    session_id: Uuid,                   // current session ID
    status_message: Option<String>,     // status bar content
}
```

#### 2.3 UI Layout

```
┌──────────────── Synapse REPL ─────────────────┐
│ [USER] Hello, how are you?                      │
│ [ASSISTANT] I'm doing well, thanks for asking! │
│ ...                                             │
│ (scrollable conversation history)               │
├─────────────────────────────────────────────────┤
│ > user input here_                              │
├─────────────────────────────────────────────────┤
│ Session: <uuid> | Provider: deepseek | /quit    │
└─────────────────────────────────────────────────┘
```

Three-area vertical layout:
1. **History area** (flex): Scrollable `Paragraph` with role-labeled messages
2. **Input area** (3 lines): Current user input with cursor
3. **Status bar** (1 line): Session ID, provider, model, hints

#### 2.4 Event Loop

Async event loop using `tokio::select!`:

```
loop {
    terminal.draw(|f| ui(f, &app))?;

    tokio::select! {
        // Terminal key events (from crossterm EventStream)
        event = event_reader.next() => { handle_key_event(event, &mut app) }

        // LLM stream events (only when streaming)
        event = llm_stream.next(), if app.is_streaming => { handle_stream_event(event, &mut app) }
    }
}
```

#### 2.5 Key Handling

| Key | Action |
|-----|--------|
| Enter | Submit input (if not empty, not streaming) |
| Backspace | Delete char before cursor |
| Left/Right | Move cursor |
| Home/End | Jump to start/end of input |
| Ctrl+C | Exit REPL |
| Up/Down | Scroll history |
| PageUp/PageDown | Scroll history by page |

#### 2.6 Input Processing

When user presses Enter:
1. Parse input for commands: `/quit` → exit
2. Store user message: `storage.add_message(user_stored_msg)`
3. Add to `app.messages` display list
4. Build full `Vec<Message>` from session history
5. Call `provider.stream(&messages)` → start streaming
6. Set `app.is_streaming = true`

When streaming completes (StreamEvent::Done):
1. Store assistant message: `storage.add_message(assistant_stored_msg)`
2. Set `app.is_streaming = false`
3. Touch session: `storage.touch_session(session_id)`

#### 2.7 Public API

```rust
pub async fn run_repl(
    config: &Config,
    provider: Box<dyn LlmProvider>,
    storage: Box<dyn SessionStore>,
    session_id: Option<Uuid>,
) -> Result<()>
```

This is the single entry point called from `main.rs`.

### 3. CLI Flag (`--repl`) (Task 9.3)

Add to `Args` struct in `main.rs`:
```rust
/// Enter interactive REPL mode
#[arg(short, long)]
repl: bool,
```

In `main()`, after subcommand check but before message handling:
```rust
if args.repl {
    return repl::run_repl(&config, provider, storage, args.session).await;
}
```

### 4. Session Resume (Task 9.4)

`--repl --session <id>` handled inside `run_repl()`:
- If `session_id` is `Some`: load session + history, populate `app.messages`
- If `session_id` is `None`: create new session

On REPL exit, print session ID to stderr (after terminal restore) so user can resume later.

## Data Flow

### New REPL Session
```
User runs: synapse --repl
  → main() parses args, args.repl == true
  → Creates provider + storage
  → Calls repl::run_repl(config, provider, storage, None)
  → run_repl creates Session, stores it
  → Enters event loop
  → User types message, presses Enter
  → Stores user message → builds message vec → provider.stream()
  → Renders TextDelta tokens to history area as they arrive
  → On Done: stores assistant message, awaits next input
  → On Ctrl+C or /quit: cleanup terminal, print session ID
```

### Resume Session
```
User runs: synapse --repl --session <uuid>
  → main() parses args, args.repl == true, args.session == Some(uuid)
  → Calls repl::run_repl(config, provider, storage, Some(uuid))
  → run_repl loads session + messages from storage
  → Populates app.messages with history
  → Enters event loop (history displayed)
  → Continues as above
```

## Non-Functional Requirements

1. **Terminal safety**: Terminal state MUST be restored on all exit paths (normal, error, panic). `TerminalGuard` with `Drop` handles this.
2. **Responsiveness**: Streaming tokens render immediately — no buffering delay.
3. **Memory**: Conversation history kept in memory for display. For very long sessions this grows unbounded, but acceptable for MVP.
4. **No core changes**: All REPL code in `synapse-cli`. No changes to `synapse-core`.

## Risks and Mitigations

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| Terminal corruption on crash | Medium | High | `TerminalGuard` Drop impl + panic hook |
| Complex async event loop | Medium | Medium | Follow established `tokio::select!` pattern from existing streaming code |
| Input editing edge cases | Low | Low | Support basic editing (backspace, left/right, home/end); not a full editor |
| Large conversation history | Low | Low | Acceptable for MVP; can add pagination later |

## Deviations to Fix

**None.** Research confirmed no deviations between existing codebase and requirements.

## Testing Strategy

1. **Unit tests** for `ReplApp` state management (input handling, message formatting)
2. **Unit tests** for command parsing (`/quit` detection)
3. **`clap` args tests** for `--repl` flag parsing (extend existing tests)
4. **Integration**: Manual testing of REPL mode with mock provider

Note: Full TUI rendering tests are impractical without a terminal. Focus on testing the logic (state transitions, message building) separately from rendering.

## File Changes Summary

| File | Change |
|------|--------|
| `synapse-cli/Cargo.toml` | Add `ratatui`, `crossterm` dependencies |
| `synapse-cli/src/main.rs` | Add `mod repl;`, add `--repl` flag, route to `repl::run_repl()` |
| `synapse-cli/src/repl.rs` | **New file**: REPL implementation |

## Open Questions

None — all requirements are clear and implementation path is defined.
