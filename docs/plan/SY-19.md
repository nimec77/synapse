# SY-19 Plan: Telegram Command Fixes & Interactive Keyboards

**Ticket:** SY-19
**Status:** PLAN_APPROVED
**Date:** 2026-02-25

---

## Summary

SY-19 fixes the command fall-through bug where `/switch` and `/delete` without arguments silently forward to the LLM, adds a `/start` welcome command, implements a defensive guard preventing any slash command from reaching the LLM, and introduces interactive inline keyboards for `/switch` and `/delete` when used without an argument. The core changes are: (1) changing `Switch(usize)` and `Delete(usize)` to `Switch(String)` and `Delete(String)` so `BotCommands::parse` always succeeds, (2) adding `parse_session_arg()` to triage empty/numeric/invalid arguments, (3) extracting `do_switch()` and `do_delete()` to share logic between slash-command and callback paths, (4) adding `InlineKeyboardMarkup` support with `handle_callback()` for `CallbackQuery` updates, and (5) restructuring the dispatcher to handle both messages and callback queries.

---

## 1. Components

| Component | File(s) | Change |
|-----------|---------|--------|
| Command enum | `synapse-telegram/src/commands.rs` | Change `Switch(usize)` to `Switch(String)`, `Delete(usize)` to `Delete(String)`; add `Start` variant |
| `parse_session_arg` | `synapse-telegram/src/commands.rs` | **NEW** helper: `&str -> Result<Option<usize>, String>` for argument triage |
| `handle_command` | `synapse-telegram/src/commands.rs` | Update match arms for `Switch(ref arg)`, `Delete(ref arg)`, `Start`; branch on `parse_session_arg` result |
| `do_switch` / `do_delete` | `synapse-telegram/src/commands.rs` | **NEW** shared logic functions extracted from `cmd_switch` / `cmd_delete`, returning `Result<String, String>` |
| `cmd_switch` / `cmd_delete` | `synapse-telegram/src/commands.rs` | Refactored to call `parse_session_arg` then delegate to `do_switch`/`do_delete` or keyboard functions |
| `build_session_keyboard` | `synapse-telegram/src/commands.rs` | **NEW**: constructs `InlineKeyboardMarkup` from session list with callback data `"action:N"` |
| `cmd_switch_keyboard` / `cmd_delete_keyboard` | `synapse-telegram/src/commands.rs` | **NEW**: send keyboard message when no argument provided |
| `handle_callback` | `synapse-telegram/src/commands.rs` | **NEW** endpoint for `CallbackQuery` updates: parse callback data, call `do_switch`/`do_delete`, edit message |
| Defensive guard | `synapse-telegram/src/handlers.rs` | Check if text starts with `/` and reply with hint instead of forwarding to LLM |
| Dispatcher | `synapse-telegram/src/main.rs` | Wrap in `dptree::entry()` with two branches: `filter_message` (existing) and `filter_callback_query` (new) |
| Tests | `synapse-telegram/src/commands.rs` | Unit tests for `parse_session_arg`, `build_session_keyboard`, defensive guard logic |

---

## 2. API Contract

### Command enum (after change)

```rust
#[derive(BotCommands, Clone)]
#[command(rename_rule = "lowercase", description = "Available commands:")]
pub enum Command {
    #[command(description = "Start the bot")]
    Start,
    #[command(description = "Show available commands")]
    Help,
    #[command(description = "Start a new session")]
    New,
    #[command(description = "Show conversation history")]
    History,
    #[command(description = "List all sessions")]
    List,
    #[command(description = "Switch to session N")]
    Switch(String),
    #[command(description = "Delete session N")]
    Delete(String),
}
```

### parse_session_arg

```rust
/// Parse a session argument string into a typed result.
///
/// - Empty string -> Ok(None) — show interactive keyboard
/// - Numeric string -> Ok(Some(n)) — direct execution with index n
/// - Non-numeric, non-empty -> Err(hint) — invalid argument
fn parse_session_arg(arg: &str) -> Result<Option<usize>, String> {
    let trimmed = arg.trim();
    if trimmed.is_empty() {
        Ok(None)
    } else {
        trimmed.parse::<usize>()
            .map(Some)
            .map_err(|_| format!(
                "Invalid argument '{}'. Use a number or omit to see a list.", trimmed
            ))
    }
}
```

### do_switch / do_delete (shared logic)

```rust
/// Execute the switch-to-session-N logic, returning a reply string.
///
/// Re-fetches the session list from storage for consistency. Returns
/// `Ok(reply)` on success or `Err(error_message)` on invalid index.
async fn do_switch(
    n: usize,
    chat_id: i64,
    storage: &Arc<Box<dyn SessionStore>>,
    chat_map: &ChatSessionMap,
) -> Result<String, String>

/// Execute the delete-session-N logic, returning a reply string.
///
/// Re-fetches the session list from storage for consistency. Returns
/// `Ok(reply)` on success or `Err(error_message)` on invalid index.
async fn do_delete(
    n: usize,
    chat_id: i64,
    config: &Config,
    storage: &Arc<Box<dyn SessionStore>>,
    chat_map: &ChatSessionMap,
) -> Result<String, String>
```

### build_session_keyboard

```rust
/// Build an inline keyboard with one button per session.
///
/// Each button's callback data follows the format `"action:N"` where
/// `action` is `"switch"` or `"delete"` and `N` is the 1-based session index.
/// The active session is marked with `*` in the button label.
fn build_session_keyboard(
    action: &str,
    sessions: &[&SessionSummary],
    active_id: Option<Uuid>,
) -> InlineKeyboardMarkup
```

### handle_callback

```rust
/// Handle inline keyboard button taps (CallbackQuery updates).
///
/// Parses callback data (`"switch:N"` or `"delete:N"`), executes the action
/// via `do_switch` / `do_delete`, and edits the keyboard message to show
/// the result text (removing the keyboard).
pub async fn handle_callback(
    bot: Bot,
    q: CallbackQuery,
    config: Arc<Config>,
    storage: Arc<Box<dyn SessionStore>>,
    chat_map: ChatSessionMap,
) -> ResponseResult<()>
```

### Updated dispatcher (main.rs)

```rust
let handler = dptree::entry()
    .branch(
        Update::filter_message()
            .branch(
                dptree::entry()
                    .filter_command::<commands::Command>()
                    .endpoint(commands::handle_command),
            )
            .branch(dptree::entry().endpoint(handlers::handle_message)),
    )
    .branch(
        Update::filter_callback_query()
            .endpoint(commands::handle_callback),
    );
```

---

## 3. Data Flows

### /switch without argument (keyboard flow)

```
User sends "/switch"
  |
  v
filter_command parses Switch("") — succeeds because String accepts empty
  |
  v
handle_command -> cmd_switch(bot, msg, "", storage, chat_map)
  |
  v
parse_session_arg("") -> Ok(None)
  |
  v
cmd_switch_keyboard(bot, msg, storage, chat_map)
  |  reads sessions from DB, builds InlineKeyboardMarkup
  v
bot.send_message(chat_id, "Select a session:")
    .reply_markup(keyboard)
  |
  v
User taps button for session 2
  |
  v
Telegram sends CallbackQuery with data = "switch:2"
  |
  v
handle_callback(bot, q, config, storage, chat_map)
  |
  v
1. bot.answer_callback_query(q.id) — dismiss loading spinner immediately
2. Parse "switch:2" -> (action="switch", n=2)
3. do_switch(2, chat_id, storage, chat_map) -> Ok("Switched to session 2.")
4. bot.edit_message_text(chat_id, message_id, "Switched to session 2.")
     — removes keyboard, prevents double-tap
```

### /switch 3 (direct execution)

```
User sends "/switch 3"
  |
  v
filter_command parses Switch("3")
  |
  v
handle_command -> cmd_switch(bot, msg, "3", storage, chat_map)
  |
  v
parse_session_arg("3") -> Ok(Some(3))
  |
  v
do_switch(3, chat_id, storage, chat_map) -> Ok("Switched to session 3.")
  |
  v
bot.send_message(chat_id, "Switched to session 3.")
```

### /switch abc (invalid argument)

```
User sends "/switch abc"
  |
  v
filter_command parses Switch("abc")
  |
  v
handle_command -> cmd_switch(bot, msg, "abc", storage, chat_map)
  |
  v
parse_session_arg("abc") -> Err("Invalid argument 'abc'. Use a number or omit to see a list.")
  |
  v
bot.send_message(chat_id, error_hint)
```

### /delete without argument (keyboard flow)

Same as /switch keyboard flow, with `"delete:N"` callback data and `do_delete()`.

### /start command

```
User sends "/start"
  |
  v
filter_command parses Start
  |
  v
handle_command -> cmd_start(bot, msg)
  |
  v
bot.send_message(chat_id, welcome_message)
```

### Defensive guard in handle_message

```
Message text starts with "/"
  |
  v
handle_message detects slash prefix
  |
  v
Reply: "I didn't understand that command. Use /help to see available commands."
  |
  v
Return early — message NOT forwarded to LLM
```

### Callback query with stale index

```
User taps button with data "switch:5"
  |
  v
handle_callback:
  1. answer_callback_query(q.id) — dismiss spinner
  2. Parse "switch:5"
  3. do_switch(5, ...) re-fetches session list from DB
  4. Index 5 is out of bounds -> Err("Invalid session index 5...")
  5. bot.edit_message_text(chat_id, msg_id, error_text)
```

---

## 4. NFR (Non-Functional Requirements)

| Requirement | How satisfied |
|-------------|---------------|
| Pre-commit gate | `cargo fmt --check && cargo clippy -- -D warnings && cargo test` |
| No `unwrap()`/`expect()` in core | All changes are in `synapse-telegram` (anyhow context); no core changes |
| No blocking I/O | All handlers are async; no blocking calls introduced |
| `thiserror` in core, `anyhow` in telegram | No core changes; telegram uses `ResponseResult` / `anyhow` |
| Hexagonal architecture | All changes are in `synapse-telegram`; `synapse-core` is untouched |
| No new crate dependencies | `teloxide 0.17` already provides `InlineKeyboardMarkup`, `CallbackQuery`, etc. |
| Backward compatibility | `/switch 3` and `/delete 2` continue to work as before; only the no-argument path changes behavior |
| Secure by default | Authorization checked in both `handle_command` and `handle_callback`; silent drop for unauthorized users |
| No `mod.rs` files | No new modules created; all code goes in existing files |
| 100 char line limit | Enforced by `cargo fmt` |

---

## 5. Risks

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| Callback data staleness (session index shifted between keyboard display and tap) | Medium | Low | `do_switch`/`do_delete` re-fetch session list from DB and validate index. Invalid index returns error that is displayed to user via message edit. |
| `edit_message_text` failure (message too old or already deleted) | Low | Low | Log at `warn` level but do not propagate; the action already succeeded. |
| `CallbackQuery.message` is `None` | Very Low | Low | Only happens for inline messages (not bot-sent). Guard with `if let Some(message) = q.regular_message()`. Log and skip edit if `None`. |
| Keyboard button text truncation | Low | Low | Cap preview text to ~30 chars in button labels to stay within Telegram's limits. |
| `answer_callback_query` called after `q.id` moved | Low | High | Clone `q.id` before borrowing `q` for `regular_message()`. Research doc confirms `q.id.clone()` is correct. |
| Telegram API rate limits on edit/answer | Very Low | Low | Low-frequency user-initiated actions; well under limits. |
| `dptree` dependency injection mismatch for `handle_callback` | Medium | High | `handle_callback` signature must match the types in `dptree::deps![]`. `CallbackQuery` is injected by `Update::filter_callback_query()`. Config, storage, and chat_map come from deps. Agent is NOT needed (callback is pure session management). |

---

## 6. Deviations to Fix

No deviations found. The existing code is consistent with all prerequisites from SY-18. The `Switch(usize)` / `Delete(usize)` types are the root cause of the fall-through bug, and changing them to `String` is the correct fix per the PRD. The defensive guard and inline keyboards are net-new functionality.

---

## 7. Implementation Tasks

### Task 1: Change Command enum types and add parse_session_arg (`commands.rs`)

**Goal:** Fix the root cause of the fall-through bug by making `Switch` and `Delete` accept any string.

1. Change `Switch(usize)` to `Switch(String)` in the `Command` enum.
2. Change `Delete(usize)` to `Delete(String)` in the `Command` enum.
3. Add the `parse_session_arg(arg: &str) -> Result<Option<usize>, String>` function:
   - Empty/whitespace-only -> `Ok(None)`
   - Valid `usize` -> `Ok(Some(n))`
   - Non-numeric -> `Err("Invalid argument '...'. Use a number or omit to see a list.")`
4. Update `handle_command` match arms:
   - `Command::Switch(ref arg) => cmd_switch(&bot, &msg, arg, &storage, &chat_map).await`
   - `Command::Delete(ref arg) => cmd_delete(&bot, &msg, arg, &config, &storage, &chat_map).await`
5. Update `cmd_switch` signature to take `arg: &str` instead of `n: usize`. Call `parse_session_arg(arg)` and branch:
   - `Ok(Some(n))` -> call `do_switch(n, ...)` (Task 5) and send reply.
   - `Ok(None)` -> call `cmd_switch_keyboard(...)` (Task 4).
   - `Err(hint)` -> send hint as reply.
6. Update `cmd_delete` signature to take `arg: &str` instead of `n: usize`. Same branching pattern.

**Files:** `synapse-telegram/src/commands.rs`

### Task 2: Add Start variant (`commands.rs`)

**Goal:** Provide the standard `/start` welcome message.

1. Add `Start` variant to the `Command` enum:
   ```rust
   #[command(description = "Start the bot")]
   Start,
   ```
2. Add match arm in `handle_command`:
   ```rust
   Command::Start => cmd_start(&bot, &msg).await,
   ```
3. Implement `cmd_start`:
   ```rust
   async fn cmd_start(bot: &Bot, msg: &TgMessage) -> ResponseResult<()> {
       let welcome = "Welcome to Synapse! I'm an AI assistant.\n\n\
           Send me a message to start chatting, or use /help to see available commands.";
       bot.send_message(msg.chat.id, welcome).await?;
       Ok(())
   }
   ```

**Files:** `synapse-telegram/src/commands.rs`

### Task 3: Add defensive guard in handle_message (`handlers.rs`)

**Goal:** Prevent any slash command from being forwarded to the LLM.

1. After extracting `text` from the message (line ~78-81 in current `handlers.rs`), add:
   ```rust
   // Defensive guard: any message starting with "/" that reached here was not
   // parsed by filter_command. Reply with a hint instead of forwarding to the LLM.
   if text.starts_with('/') {
       bot.send_message(
           msg.chat.id,
           "I didn't understand that command. Use /help to see available commands.",
       )
       .await?;
       return Ok(());
   }
   ```
2. This guard catches: (a) typos like `/hlep`, (b) future commands that `filter_command` fails to parse, (c) commands from other bots in group chats that are not recognized.

**Files:** `synapse-telegram/src/handlers.rs`

### Task 4: Add keyboard builder functions (`commands.rs`)

**Goal:** Build and send inline keyboards for session selection.

1. Add necessary imports at the top of `commands.rs`:
   ```rust
   use teloxide::types::{
       CallbackQuery, InlineKeyboardButton, InlineKeyboardMarkup,
   };
   use teloxide::payloads::SendMessageSetters;
   ```
2. Implement `build_session_keyboard`:
   ```rust
   fn build_session_keyboard(
       action: &str,
       sessions: &[&SessionSummary],
       active_id: Option<Uuid>,
   ) -> InlineKeyboardMarkup {
       let buttons: Vec<Vec<InlineKeyboardButton>> = sessions
           .iter()
           .enumerate()
           .map(|(i, s)| {
               let idx = i + 1; // 1-based
               let active_marker = if Some(s.id) == active_id { "*" } else { " " };
               let date = s.updated_at.format("%Y-%m-%d").to_string();
               let preview = s.preview.as_deref().unwrap_or("")
                   .chars().take(20).collect::<String>();
               let label = format!(
                   "{}. [{}] {} | {} msgs | {}",
                   idx, active_marker, date, s.message_count, preview
               );
               let data = format!("{}:{}", action, idx);
               vec![InlineKeyboardButton::callback(label, data)]
           })
           .collect();
       InlineKeyboardMarkup::new(buttons)
   }
   ```
3. Implement `cmd_switch_keyboard`:
   ```rust
   async fn cmd_switch_keyboard(
       bot: &Bot,
       msg: &TgMessage,
       storage: &Arc<Box<dyn SessionStore>>,
       chat_map: &ChatSessionMap,
   ) -> ResponseResult<()> {
       let chat_id = msg.chat.id.0;
       // Read sessions and build keyboard (same session list logic as cmd_list)
       // If no sessions, reply with hint.
       // Otherwise send message with InlineKeyboardMarkup.
   }
   ```
4. Implement `cmd_delete_keyboard` (same pattern, with `action = "delete"`).
5. Helper function to read sessions for keyboard/shared logic:
   ```rust
   /// Fetch the display-ordered session list for a chat.
   /// Returns (filtered sessions, active session ID) or None if no sessions.
   async fn fetch_chat_sessions(
       chat_id: i64,
       storage: &Arc<Box<dyn SessionStore>>,
       chat_map: &ChatSessionMap,
   ) -> Option<(Vec<SessionSummary>, Option<Uuid>)>
   ```
   This avoids duplicating the session-fetch-and-filter pattern across `do_switch`, `do_delete`, `cmd_switch_keyboard`, and `cmd_delete_keyboard`. The function reads `chat_map` for UUIDs and `active_id`, calls `storage.list_sessions()`, and filters.

**Files:** `synapse-telegram/src/commands.rs`

### Task 5: Extract do_switch / do_delete and add handle_callback (`commands.rs`)

**Goal:** Share logic between slash-commands and callback buttons.

1. Extract `do_switch` from the current `cmd_switch` body:
   ```rust
   async fn do_switch(
       n: usize,
       chat_id: i64,
       storage: &Arc<Box<dyn SessionStore>>,
       chat_map: &ChatSessionMap,
   ) -> Result<String, String> {
       // Re-fetch session list from storage (handles staleness).
       // Validate n against display list length.
       // Find target UUID, update active_idx in chat_map.
       // Touch session.
       // Return Ok("Switched to session N.") or Err("Invalid session index N...").
   }
   ```
2. Extract `do_delete` from the current `cmd_delete` body:
   ```rust
   async fn do_delete(
       n: usize,
       chat_id: i64,
       config: &Config,
       storage: &Arc<Box<dyn SessionStore>>,
       chat_map: &ChatSessionMap,
   ) -> Result<String, String> {
       // Same session list reconstruction.
       // Validate index.
       // Delete from storage and chat_map.
       // Handle active session deletion (switch to 0 or auto-create).
       // Return reply string.
   }
   ```
3. Refactor `cmd_switch` and `cmd_delete` to delegate to `do_switch`/`do_delete`:
   ```rust
   // In cmd_switch, after parse_session_arg returns Ok(Some(n)):
   let reply = match do_switch(n, chat_id, storage, chat_map).await {
       Ok(msg) | Err(msg) => msg,
   };
   bot.send_message(msg.chat.id, reply).await?;
   ```
4. Implement `handle_callback`:
   ```rust
   pub async fn handle_callback(
       bot: Bot,
       q: CallbackQuery,
       config: Arc<Config>,
       storage: Arc<Box<dyn SessionStore>>,
       chat_map: ChatSessionMap,
   ) -> ResponseResult<()> {
       // 1. Authorization check.
       let user_id = q.from.id.0;
       let allowed_users = config.telegram.as_ref()
           .map(|t| t.allowed_users.as_slice()).unwrap_or(&[]);
       if !is_authorized(user_id, allowed_users) {
           return Ok(());
       }

       // 2. Answer callback query immediately (dismiss loading spinner).
       bot.answer_callback_query(q.id.clone()).await?;

       // 3. Parse callback data.
       let data = match q.data.as_deref() {
           Some(d) => d,
           None => return Ok(()),
       };

       // 4. Extract chat_id from the original message.
       let message = match q.regular_message() {
           Some(m) => m,
           None => {
               tracing::warn!("Callback query without regular message, skipping");
               return Ok(());
           }
       };
       let chat_id = message.chat.id.0;

       // 5. Parse "action:N" format.
       let (action, n) = match parse_callback_data(data) {
           Some(parsed) => parsed,
           None => {
               tracing::warn!("Invalid callback data: {}", data);
               return Ok(());
           }
       };

       // 6. Execute action.
       let reply = match action {
           "switch" => match do_switch(n, chat_id, &storage, &chat_map).await {
               Ok(msg) | Err(msg) => msg,
           },
           "delete" => match do_delete(n, chat_id, &config, &storage, &chat_map).await {
               Ok(msg) | Err(msg) => msg,
           },
           _ => {
               tracing::warn!("Unknown callback action: {}", action);
               return Ok(());
           }
       };

       // 7. Edit message to remove keyboard and show result.
       if let Err(e) = bot
           .edit_message_text(message.chat.id, message.id, &reply)
           .await
       {
           tracing::warn!("Failed to edit callback message: {}", e);
       }

       Ok(())
   }
   ```
5. Add `parse_callback_data` helper:
   ```rust
   /// Parse callback data in the format "action:N" (e.g., "switch:2", "delete:1").
   fn parse_callback_data(data: &str) -> Option<(&str, usize)> {
       let (action, n_str) = data.split_once(':')?;
       let n = n_str.parse::<usize>().ok()?;
       Some((action, n))
   }
   ```

**Files:** `synapse-telegram/src/commands.rs`

### Task 6: Restructure dispatcher (`main.rs`)

**Goal:** Handle both message updates and callback query updates.

1. Change the handler tree from message-only to entry-point with two branches:
   ```rust
   let handler = dptree::entry()
       .branch(
           Update::filter_message()
               .branch(
                   dptree::entry()
                       .filter_command::<commands::Command>()
                       .endpoint(commands::handle_command),
               )
               .branch(dptree::entry().endpoint(handlers::handle_message)),
       )
       .branch(
           Update::filter_callback_query()
               .endpoint(commands::handle_callback),
       );
   ```
2. The `dptree::deps![]` already includes `config`, `storage`, and `chat_map` which `handle_callback` needs. `CallbackQuery` is injected by `Update::filter_callback_query()`. No changes to deps needed.
3. Verify that `handle_callback` does NOT require `Agent` in its signature (it does not -- callbacks are pure session management).

**Files:** `synapse-telegram/src/main.rs`

### Task 7: Unit tests (`commands.rs`)

**Goal:** Test all new pure functions and logic paths.

1. **`test_parse_session_arg_empty`**: `parse_session_arg("")` returns `Ok(None)`.
2. **`test_parse_session_arg_whitespace`**: `parse_session_arg("  ")` returns `Ok(None)`.
3. **`test_parse_session_arg_numeric`**: `parse_session_arg("3")` returns `Ok(Some(3))`.
4. **`test_parse_session_arg_zero`**: `parse_session_arg("0")` returns `Ok(Some(0))` (index validation happens later in `do_switch`/`do_delete`).
5. **`test_parse_session_arg_non_numeric`**: `parse_session_arg("abc")` returns `Err(hint)` containing "Invalid argument".
6. **`test_parse_session_arg_negative`**: `parse_session_arg("-1")` returns `Err(hint)` (negative numbers fail `usize` parse).
7. **`test_parse_callback_data_valid_switch`**: `parse_callback_data("switch:2")` returns `Some(("switch", 2))`.
8. **`test_parse_callback_data_valid_delete`**: `parse_callback_data("delete:1")` returns `Some(("delete", 1))`.
9. **`test_parse_callback_data_invalid_no_colon`**: `parse_callback_data("switch2")` returns `None`.
10. **`test_parse_callback_data_invalid_non_numeric`**: `parse_callback_data("switch:abc")` returns `None`.
11. **`test_build_session_keyboard_callback_data`**: Build a keyboard with 2 sessions using `action = "switch"`, verify each button's callback data is `"switch:1"` and `"switch:2"`.
12. **`test_build_session_keyboard_active_marker`**: Build keyboard where second session is active, verify `*` appears in the second button's label and ` ` in the first.
13. **`test_build_session_keyboard_empty_sessions`**: Build keyboard with empty session list, verify the keyboard has no buttons.
14. **`test_defensive_guard_slash_detection`**: Verify that strings starting with `/` would be caught (test the condition `text.starts_with('/')`, not the handler itself since it requires a Bot instance).

**Files:** `synapse-telegram/src/commands.rs`

---

## 8. Implementation Order and Dependencies

```
Task 1 (enum type change + parse_session_arg)
  |
  +---> Task 2 (Start variant) — independent, can be done in parallel with Task 1
  |
  +---> Task 3 (defensive guard) — independent, can be done in parallel
  |
  v
Task 4 (keyboard builders) — depends on Task 1 for the new String-based enum
  |
  v
Task 5 (do_switch/do_delete + handle_callback) — depends on Tasks 1 and 4
  |
  v
Task 6 (dispatcher restructure) — depends on Task 5 (needs handle_callback to exist)
  |
  v
Task 7 (unit tests) — depends on all previous tasks
```

The recommended sequential implementation order is: 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7. Tasks 1, 2, and 3 are relatively independent but Task 1 must be done first since Tasks 4 and 5 depend on the new `String`-based enum.

---

## 9. Open Questions

None. The PRD, phase document, and research document provide comprehensive specifications for all tasks. All technical questions from the research (e.g., `BotMessagesExt` vs direct API, `CallbackQueryId` cloning, authorization for callbacks) are resolved in the research document.
