# SY-18 Plan: Telegram Bot Commands

**Ticket:** SY-18
**Status:** PLAN_APPROVED
**Date:** 2026-02-24

---

## Summary

SY-18 adds slash command support to the Telegram bot with six commands (`/help`, `/new`, `/history`, `/list`, `/switch N`, `/delete N`), multi-session management per chat, and a configurable `max_sessions_per_chat` setting (default 10) in `TelegramConfig`. The core data structure change is replacing the single-UUID-per-chat `ChatSessionMap` with a `ChatSessions` struct that tracks multiple session UUIDs and an active session index. The dispatcher switches from a single-endpoint handler to a branched pattern separating commands from regular messages.

---

## 1. Components

| Component | File(s) | Change |
|-----------|---------|--------|
| TelegramConfig | `synapse-core/src/config.rs` | Add `max_sessions_per_chat: u32` field (serde default `10`); replace `#[derive(Default)]` with manual `Default` impl |
| Cargo.toml | `synapse-telegram/Cargo.toml` | Move `chrono` from `[dev-dependencies]` to `[dependencies]` |
| ChatSessions struct | `synapse-telegram/src/handlers.rs` | New `ChatSessions` struct; update `ChatSessionMap` type alias |
| resolve_session | `synapse-telegram/src/handlers.rs` | Update to read active session from `ChatSessions` and create initial `ChatSessions` entries |
| handle_message | `synapse-telegram/src/handlers.rs` | Type signature update only (new `ChatSessionMap` type flows through) |
| Command enum + handlers | `synapse-telegram/src/commands.rs` | **NEW** file: `Command` enum with `BotCommands` derive; `handle_command()` dispatcher; six command implementations |
| Dispatcher setup | `synapse-telegram/src/main.rs` | Branched handler, `Me` injection, `set_my_commands` call at startup |
| rebuild_chat_map | `synapse-telegram/src/main.rs` | Return `HashMap<i64, ChatSessions>` grouping multiple sessions per chat |
| Tests | `synapse-core/src/config.rs`, `synapse-telegram/src/main.rs`, `synapse-telegram/src/commands.rs` | Config deserialization, multi-session rebuild, command logic unit tests |

---

## 2. API Contract

### TelegramConfig (after change)

```rust
#[derive(Debug, Clone, PartialEq, Deserialize)]
pub struct TelegramConfig {
    #[serde(default)]
    pub token: Option<String>,
    #[serde(default)]
    pub allowed_users: Vec<u64>,
    #[serde(default = "default_max_sessions_per_chat")]
    pub max_sessions_per_chat: u32,
}

fn default_max_sessions_per_chat() -> u32 {
    10
}

impl Default for TelegramConfig {
    fn default() -> Self {
        Self {
            token: None,
            allowed_users: vec![],
            max_sessions_per_chat: default_max_sessions_per_chat(),
        }
    }
}
```

### ChatSessions struct (new)

```rust
/// Per-chat session state: ordered list of session UUIDs and the active session index.
#[derive(Debug, Clone)]
pub struct ChatSessions {
    /// Session UUIDs ordered by updated_at DESC (most recent first).
    /// This order matches the 1-based index in /list, /switch, /delete.
    pub sessions: Vec<Uuid>,
    /// Index into `sessions` indicating the currently active session.
    pub active_idx: usize,
}

impl ChatSessions {
    /// Return the currently active session UUID, if any.
    pub fn active_session_id(&self) -> Option<Uuid> {
        self.sessions.get(self.active_idx).copied()
    }
}

pub type ChatSessionMap = Arc<RwLock<HashMap<i64, ChatSessions>>>;
```

### Command enum

```rust
use teloxide::utils::command::BotCommands;

#[derive(BotCommands, Clone)]
#[command(rename_rule = "lowercase", description = "Available commands:")]
pub enum Command {
    #[command(description = "Show available commands")]
    Help,
    #[command(description = "Start a new session")]
    New,
    #[command(description = "Show conversation history")]
    History,
    #[command(description = "List all sessions")]
    List,
    #[command(description = "Switch to session N")]
    Switch(usize),
    #[command(description = "Delete session N")]
    Delete(usize),
}
```

### Command handler signature

```rust
pub async fn handle_command(
    bot: Bot,
    msg: TgMessage,
    cmd: Command,
    config: Arc<Config>,
    storage: Arc<Box<dyn SessionStore>>,
    chat_map: ChatSessionMap,
) -> ResponseResult<()>
```

Note: `Agent` is not needed in the command handler since none of the six commands invoke LLM inference. Only `handle_message` (regular text) needs the `Agent`.

### Branched dispatcher

```rust
let handler = Update::filter_message()
    .branch(dptree::entry().filter_command::<Command>().endpoint(commands::handle_command))
    .branch(dptree::entry().endpoint(handlers::handle_message));
```

### rebuild_chat_map (after change)

```rust
pub async fn rebuild_chat_map(storage: &dyn SessionStore) -> HashMap<i64, ChatSessions> {
    // list_sessions() returns ORDER BY updated_at DESC
    // Group by chat_id, first encountered = most recent = active
}
```

---

## 3. Data Flows

### Command routing

```
Telegram Update (message)
  |
  v
Update::filter_message()
  |
  +--> branch 1: filter_command::<Command>()
  |      |  parse text as /help, /new, /history, /list, /switch N, /delete N
  |      v
  |    commands::handle_command(bot, msg, cmd, config, storage, chat_map)
  |      |  match cmd { Help => ..., New => ..., ... }
  |      v
  |    Bot reply (plain text, no LLM invocation)
  |
  +--> branch 2: fallback (non-command text)
         |
         v
       handlers::handle_message(bot, msg, config, agent, storage, chat_map)
         |  resolve_session -> agent.complete() -> send response
         v
       Bot reply (HTML-formatted LLM response)
```

### /new command flow

```
/new received
  |
  v
Read ChatSessionMap for this chat_id
  |  count = chat_sessions.sessions.len()
  v
count >= max_sessions_per_chat?
  |
  +--> Yes: find oldest session (last in vec, lowest updated_at)
  |         storage.delete_session(oldest_id)
  |         remove from chat_sessions.sessions vec
  |
  v
Create Session::new(provider, model).with_name("tg:<chat_id>")
  |
  v
storage.create_session(&session)
  |
  v
Insert session.id at front of chat_sessions.sessions
Set chat_sessions.active_idx = 0
  |
  v
Reply: "New session created." (or "New session created. Oldest session removed." if evicted)
```

### /list command flow

```
/list received
  |
  v
Read ChatSessions for this chat_id
  |
  v
Call storage.list_sessions()
  |  returns all sessions ORDER BY updated_at DESC
  v
Filter to only session UUIDs present in chat_sessions.sessions
  |  preserves DB ordering (most recent first)
  v
Format numbered list:
  "1. [*] 2026-02-24 14:30 | 5 msgs | Hello, how are..."
  "2.     2026-02-23 09:15 | 12 msgs | Can you help me..."
  (* marks active session)
  |
  v
Reply as plain text (chunked if > 4096 chars)
```

### /switch N command flow

```
/switch N received
  |
  v
Read ChatSessions for this chat_id
  |
  v
Validate: N >= 1 && N <= sessions.len()
  |
  +--> Invalid: Reply "Invalid session index. Use /list to see available sessions."
  |
  v
Set active_idx = N - 1
storage.touch_session(sessions[N-1])
  |
  v
Reply: "Switched to session N."
```

### /delete N command flow

```
/delete N received
  |
  v
Read ChatSessions for this chat_id
  |
  v
Validate: N >= 1 && N <= sessions.len()
  |
  +--> Invalid: Reply "Invalid session index. Use /list to see available sessions."
  |
  v
session_id = sessions[N - 1]
storage.delete_session(session_id)
Remove from sessions vec
  |
  v
Was the deleted session the active one?
  |
  +--> Yes, other sessions remain:
  |      Set active_idx = 0 (most recent remaining)
  |      Reply: "Session N deleted. Switched to session 1."
  |
  +--> Yes, no sessions remain:
  |      Auto-create a new session (same as /new without cap check)
  |      Reply: "Session deleted. New session created."
  |
  +--> No (deleted a non-active session):
         Adjust active_idx if needed (if deleted index < active_idx, decrement)
         Reply: "Session N deleted."
```

---

## 4. NFR (Non-Functional Requirements)

| Requirement | How satisfied |
|-------------|---------------|
| Pre-commit gate | `cargo fmt --check && cargo clippy -- -D warnings && cargo test` |
| No `unwrap()`/`expect()` in core | Only `synapse-core/src/config.rs` changes; new field is `u32` with serde default, no unwrapping needed |
| No blocking I/O | All command handlers are async; no blocking calls introduced |
| `thiserror` in core, `anyhow` in telegram | Config field addition uses existing patterns; command handlers use `anyhow` via `ResponseResult` |
| Hexagonal architecture | `synapse-core` gains only a config field; all Telegram-specific logic stays in `synapse-telegram` |
| Backward compatibility | Non-command messages route to active session as before; existing single-session chats auto-migrate |
| Secure by default | Authorization check applies to all commands (reuse `is_authorized()`) |

---

## 5. Risks

| Risk | Likelihood | Impact | Mitigation |
|------|-----------|--------|------------|
| Session index shift between `/list` and `/switch` | Medium | Low | Acceptable UX; user can re-run `/list`. Document that indexes reflect current ordering. |
| `TelegramConfig::default()` returning `max_sessions_per_chat: 0` with `#[derive(Default)]` | High | High | Replace `#[derive(Default)]` with manual `impl Default` that returns `10`. |
| `set_my_commands` failure at startup | Low | Low | Log warning but do not abort. Commands still work without autocomplete. |
| Race conditions on rapid concurrent commands | Low | Medium | `RwLock` serializes access. Commands that modify `ChatSessions` acquire write lock. Double-check pattern preserved in `resolve_session`. |
| `/history` output exceeding 4096 chars | Medium | Low | Use `chunk_message()` for plain text splitting. |
| `filter_command` requires `Me` type in deps | High | High | Call `bot.get_me().await?` at startup and inject `Me` into `dptree::deps![]`. |
| Existing tests construct `TelegramConfig` without `max_sessions_per_chat` | High | Medium | All existing tests that construct `TelegramConfig { token: ..., allowed_users: ... }` must add `max_sessions_per_chat` field or use `..TelegramConfig::default()`. |

---

## 6. Deviations to Fix

No deviations found. The research document confirms the current codebase is consistent with all prerequisites. The implementation is greenfield (new functionality, no existing code contradicts requirements).

---

## 7. Implementation Tasks

### Task 1: Add `max_sessions_per_chat` to `TelegramConfig` (`synapse-core/src/config.rs`)

1. Add `default_max_sessions_per_chat()` function returning `10u32`, placed near other default functions.
2. Add `max_sessions_per_chat: u32` field to `TelegramConfig` with `#[serde(default = "default_max_sessions_per_chat")]`.
3. Remove `#[derive(..., Default)]` from `TelegramConfig` and add a manual `impl Default`:
   ```rust
   impl Default for TelegramConfig {
       fn default() -> Self {
           Self {
               token: None,
               allowed_users: vec![],
               max_sessions_per_chat: default_max_sessions_per_chat(),
           }
       }
   }
   ```
4. Update existing test `test_telegram_config_default` to assert `max_sessions_per_chat == 10`.
5. Add new test `test_config_telegram_max_sessions_per_chat`:
   - Parse TOML with `max_sessions_per_chat = 5` and assert the value.
   - Parse TOML with `[telegram]` section but no `max_sessions_per_chat` and assert default `10`.
6. Update all test callsites that construct `TelegramConfig { token: ..., allowed_users: ... }` to include `max_sessions_per_chat` or use `..TelegramConfig::default()`. This affects tests in `synapse-telegram/src/main.rs` (token resolution tests).

**Files:** `synapse-core/src/config.rs`, `synapse-telegram/src/main.rs` (test updates)

### Task 2: Move `chrono` dependency (`synapse-telegram/Cargo.toml`)

1. Move `chrono = "0.4"` from `[dev-dependencies]` to `[dependencies]`.
2. Remove the empty `[dev-dependencies]` section (or leave it if other dev-deps exist).

**Files:** `synapse-telegram/Cargo.toml`

### Task 3: Update `ChatSessionMap` type and `resolve_session` (`synapse-telegram/src/handlers.rs`)

1. Add the `ChatSessions` struct:
   ```rust
   /// Per-chat session state: ordered list of session UUIDs and the active session index.
   #[derive(Debug, Clone)]
   pub struct ChatSessions {
       /// Session UUIDs for this chat. Order may not match DB ordering;
       /// use list_sessions() for display ordering.
       pub sessions: Vec<Uuid>,
       /// Index into `sessions` indicating the currently active session.
       pub active_idx: usize,
   }

   impl ChatSessions {
       /// Return the currently active session UUID, if any.
       pub fn active_session_id(&self) -> Option<Uuid> {
           self.sessions.get(self.active_idx).copied()
       }
   }
   ```
2. Update the `ChatSessionMap` type alias:
   ```rust
   pub type ChatSessionMap = Arc<RwLock<HashMap<i64, ChatSessions>>>;
   ```
3. Update `resolve_session` to work with the new type:
   - Fast path (read lock): check for `ChatSessions` entry and return `active_session_id()`.
   - Slow path (write lock): create new session, insert a `ChatSessions { sessions: vec![session.id], active_idx: 0 }`.
   - Double-check pattern preserved.
4. Update `handle_message` -- no functional changes needed, but the `ChatSessionMap` type it receives has changed. Verify it compiles.

**Files:** `synapse-telegram/src/handlers.rs`

### Task 4: Create `commands.rs` (`synapse-telegram/src/commands.rs`)

1. Create new file `synapse-telegram/src/commands.rs`.
2. Define the `Command` enum with `#[derive(BotCommands, Clone)]`:
   ```rust
   #[derive(BotCommands, Clone)]
   #[command(rename_rule = "lowercase", description = "Available commands:")]
   pub enum Command {
       #[command(description = "Show available commands")]
       Help,
       #[command(description = "Start a new session")]
       New,
       #[command(description = "Show conversation history")]
       History,
       #[command(description = "List all sessions")]
       List,
       #[command(description = "Switch to session N")]
       Switch(usize),
       #[command(description = "Delete session N")]
       Delete(usize),
   }
   ```
3. Implement `handle_command()` as the single endpoint for all commands. It receives `cmd: Command` via dptree injection and dispatches via `match`:
   ```rust
   pub async fn handle_command(
       bot: Bot,
       msg: TgMessage,
       cmd: Command,
       config: Arc<Config>,
       storage: Arc<Box<dyn SessionStore>>,
       chat_map: ChatSessionMap,
   ) -> ResponseResult<()> {
       // Authorization check (same as handle_message)
       let user_id = msg.from.as_ref().map(|u| u.id.0).unwrap_or(0);
       let allowed_users = config.telegram.as_ref()
           .map(|t| t.allowed_users.as_slice()).unwrap_or(&[]);
       if !handlers::is_authorized(user_id, allowed_users) {
           return Ok(());
       }

       match cmd {
           Command::Help => cmd_help(&bot, &msg).await,
           Command::New => cmd_new(&bot, &msg, &config, &storage, &chat_map).await,
           Command::History => cmd_history(&bot, &msg, &storage, &chat_map).await,
           Command::List => cmd_list(&bot, &msg, &storage, &chat_map).await,
           Command::Switch(n) => cmd_switch(&bot, &msg, n, &storage, &chat_map).await,
           Command::Delete(n) => cmd_delete(&bot, &msg, n, &config, &storage, &chat_map).await,
       }
   }
   ```
4. Implement each command handler as a private async function:

   **`cmd_help`**: Reply with `Command::descriptions().to_string()`.

   **`cmd_new`**:
   - Get chat_id from `msg.chat.id.0`.
   - Acquire write lock on `chat_map`.
   - Count existing sessions for this chat.
   - If at cap (`max_sessions_per_chat`): identify oldest session (last in vec when using DB ordering, or find by cross-referencing `list_sessions()`), call `storage.delete_session()`, remove from vec.
   - Create `Session::new(&config.provider, &config.model).with_name(format!("tg:{}", chat_id))`.
   - Call `storage.create_session(&session)`.
   - Insert `session.id` into `ChatSessions` (push to front or append and set active).
   - Set `active_idx` to point to the new session.
   - Reply confirming creation (and eviction if applicable).

   **`cmd_history`**:
   - Get active session ID from `chat_map`.
   - If no active session, reply "No active session. Send a message or use /new to start one."
   - Call `storage.get_messages(session_id)`.
   - If empty, reply "No messages in current session."
   - Format each message: `"[role] timestamp\ncontent"` using `chrono` for timestamp formatting (e.g., `msg.timestamp.format("%Y-%m-%d %H:%M")`).
   - Chunk with `handlers::chunk_message()` and send each chunk as plain text.

   **`cmd_list`**:
   - Get `ChatSessions` for this chat from `chat_map` (read lock).
   - If no sessions, reply "No sessions. Send a message or use /new to start one."
   - Call `storage.list_sessions()` to get metadata (ordered by `updated_at DESC`).
   - Filter to only sessions whose UUID is in the chat's session list.
   - Format numbered list (1-based), marking the active session with `*`:
     ```
     1. * 2026-02-24 14:30 | 5 msgs | Hello, how are...
     2.   2026-02-23 09:15 | 12 msgs | Can you help me...
     ```
   - The index N in the display corresponds to the position in the filtered+ordered list. The `/switch N` and `/delete N` commands use this same ordering.
   - Chunk and send as plain text.

   **`cmd_switch`**:
   - Read `ChatSessions` for this chat.
   - Validate: `n >= 1 && n <= sessions_count`. sessions_count is derived from the display-order list (same as `/list`).
   - If invalid: reply "Invalid session index N. Use /list to see available sessions."
   - Fetch the session list from `list_sessions()`, filter to this chat's sessions, and identify the UUID at position `n-1` in the sorted list.
   - Find that UUID's position in `ChatSessions.sessions` and set `active_idx`.
   - Call `storage.touch_session()` on the switched-to session.
   - Reply "Switched to session N."

   **`cmd_delete`**:
   - Read `ChatSessions` for this chat.
   - Validate index bounds (same as `/switch`).
   - Identify the session UUID at the display-order index.
   - Call `storage.delete_session(session_id)`.
   - Remove UUID from `ChatSessions.sessions` vec.
   - If deleted session was the active one:
     - If other sessions remain: set `active_idx = 0`.
     - If no sessions remain: auto-create a new session and set it as active.
   - If deleted session was not the active one: adjust `active_idx` if it was shifted by the removal.
   - Reply confirming deletion.

5. Declare `mod commands;` in `synapse-telegram/src/main.rs`.

**Files:** `synapse-telegram/src/commands.rs`, `synapse-telegram/src/main.rs`

### Task 5: Update dispatcher and `rebuild_chat_map` (`synapse-telegram/src/main.rs`)

1. Add `mod commands;` declaration at the top alongside `mod format;` and `mod handlers;`.
2. Add import for `commands::Command`.
3. Call `bot.get_me().await?` before dispatcher setup and store as `me: teloxide::types::Me`.
4. Call `bot.set_my_commands(Command::bot_commands()).await` at startup. Log a warning if it fails but do not abort:
   ```rust
   if let Err(e) = bot.set_my_commands(Command::bot_commands()).await {
       tracing::warn!("Failed to register bot commands: {}", e);
   }
   ```
5. Switch to branched handler:
   ```rust
   let handler = Update::filter_message()
       .branch(dptree::entry().filter_command::<Command>().endpoint(commands::handle_command))
       .branch(dptree::entry().endpoint(handlers::handle_message));
   ```
6. Inject `me` into the dependency map:
   ```rust
   Dispatcher::builder(bot, handler)
       .dependencies(dptree::deps![
           me,
           Arc::clone(&config),
           Arc::clone(&agent),
           Arc::clone(&storage),
           chat_map
       ])
   ```
7. Update `rebuild_chat_map` to return `HashMap<i64, ChatSessions>`:
   ```rust
   pub async fn rebuild_chat_map(storage: &dyn SessionStore) -> HashMap<i64, ChatSessions> {
       let sessions: Vec<SessionSummary> = storage.list_sessions().await.unwrap_or_default();
       let mut map: HashMap<i64, Vec<Uuid>> = HashMap::new();

       // list_sessions() returns ORDER BY updated_at DESC
       for s in &sessions {
           if let Some(chat_id) = s.name.as_deref()
               .and_then(|n| n.strip_prefix("tg:"))
               .and_then(|id_str| id_str.parse::<i64>().ok())
           {
               map.entry(chat_id).or_default().push(s.id);
           }
       }

       map.into_iter()
           .map(|(chat_id, session_ids)| {
               (chat_id, ChatSessions {
                   sessions: session_ids,
                   active_idx: 0, // Most recent session is active
               })
           })
           .collect()
   }
   ```
8. Update the startup log to report total sessions across all chats:
   ```rust
   let total_sessions: usize = initial_map.values().map(|cs| cs.sessions.len()).sum();
   tracing::info!(
       "Restored {} Telegram sessions across {} chats from storage",
       total_sessions,
       initial_map.len()
   );
   ```

**Files:** `synapse-telegram/src/main.rs`

### Task 6: Update existing tests (`synapse-telegram/src/main.rs`)

1. Update `test_resolve_token_env_var` and `test_resolve_token_config` and `test_resolve_token_empty_env_var` to construct `TelegramConfig` with the new `max_sessions_per_chat` field. Use `..TelegramConfig::default()` to avoid listing all fields:
   ```rust
   TelegramConfig {
       token: Some("config-token".to_string()),
       allowed_users: vec![],
       ..TelegramConfig::default()
   }
   ```
2. Update `test_rebuild_chat_map_*` tests for the new return type:
   - `test_rebuild_chat_map_empty`: assert `map.is_empty()` (unchanged).
   - `test_rebuild_chat_map_with_telegram_sessions`: assert `map.len() == 2`, verify each `ChatSessions` has the correct UUID in `sessions` vec and `active_idx == 0`.
   - `test_rebuild_chat_map_ignores_non_telegram`: assert only tg session present.
3. Add new test `test_rebuild_chat_map_multi_session_per_chat`:
   - Create multiple `SessionSummary` entries with the same `tg:<chat_id>` name but different UUIDs and `updated_at` timestamps.
   - Assert that `rebuild_chat_map` groups them under the same chat_id.
   - Assert that the first UUID in `sessions` vec is the most recently updated (since `list_sessions()` returns DESC order).
   - Assert `active_idx == 0`.

**Files:** `synapse-telegram/src/main.rs`

### Task 7: Add unit tests for command logic (`synapse-telegram/src/commands.rs`)

1. Add tests in a `#[cfg(test)] mod tests` block within `commands.rs`.
2. Reuse or adapt the `MockSessionStore` pattern from `main.rs` tests (may need to extract to a shared test utility, or duplicate for now).
3. Test `ChatSessions::active_session_id()`:
   - Returns `Some(uuid)` for valid `active_idx`.
   - Returns `None` for empty sessions vec.
4. Test session cap enforcement logic (can be tested via helper functions extracted from `cmd_new` if feasible, or via integration-style tests with mock storage).
5. Test index validation for `/switch` and `/delete`:
   - Valid index within bounds.
   - Index 0 (invalid, 1-based).
   - Index exceeding session count.
6. Test `/delete` active session adjustment:
   - Deleting active session switches to index 0.
   - Deleting non-active session adjusts `active_idx` correctly.

**Files:** `synapse-telegram/src/commands.rs`

### Task 8: Update `config.example.toml`

Add a `max_sessions_per_chat` entry in the `[telegram]` section:

```toml
[telegram]
# token = "your-bot-token"
# allowed_users = [123456789]
# Maximum sessions per Telegram chat (default: 10).
# When exceeded, the oldest session is auto-deleted on /new.
# max_sessions_per_chat = 10
```

**Files:** `config.example.toml`

### Task 9: Verify and run pre-commit checks

1. Run `cargo fmt --check` to verify formatting.
2. Run `cargo clippy -- -D warnings` to verify no new warnings.
3. Run `cargo test` to verify all tests pass.

---

## 8. Session Index Ordering Strategy

The `/list`, `/switch N`, and `/delete N` commands all depend on a consistent, deterministic session ordering. The strategy is:

1. **Display ordering comes from the database** via `list_sessions()` which returns `ORDER BY updated_at DESC`.
2. **The in-memory `ChatSessions.sessions` vec** tracks which sessions belong to a chat and which is active, but is NOT the source of truth for display ordering.
3. **For `/list`**: call `list_sessions()`, filter to this chat's UUIDs, display in the DB-returned order. The 1-based index corresponds to position in this filtered list.
4. **For `/switch N` and `/delete N`**: reconstruct the same filtered+ordered list from `list_sessions()`, then map index N to a UUID. This ensures the index always matches what `/list` shows, even if `updated_at` values have changed since the last `/list` call.
5. **For `resolve_session` (regular messages)**: use `ChatSessions.active_idx` to look up the active UUID directly from the in-memory vec. No DB call needed for the hot path.

This separation means the in-memory vec is optimized for the common case (sending messages) while display-related commands always get fresh ordering from the DB.

---

## 9. Open Questions

None. The PRD, phase documentation, and research document provide comprehensive detail. All design decisions are clear:
- `ChatSessions` struct with `Vec<Uuid>` and `active_idx: usize`
- Manual `Default` for `TelegramConfig` to ensure `max_sessions_per_chat = 10`
- Branched dispatcher with `filter_command::<Command>()`
- `Me` injection for bot command parsing
- Plain text output for informational commands (`/help`, `/history`, `/list`)
- `list_sessions()` as source of truth for display ordering
- Session cap enforced only in `/new` handler
