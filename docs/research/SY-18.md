# SY-18 Research: Telegram Bot Commands

**Ticket:** SY-18
**Date:** 2026-02-24
**Status:** Research Complete

---

## 1. PRD Summary

SY-18 adds slash command support to the Telegram bot with six commands (`/help`, `/new`, `/history`, `/list`, `/switch N`, `/delete N`), multi-session management per chat, and a configurable `max_sessions_per_chat` setting (default 10) in `TelegramConfig`. The `ChatSessionMap` type must change from single-UUID-per-chat to multi-UUID-per-chat with an "active session" concept. The `rebuild_chat_map` function must be updated to collect multiple sessions per chat. The `chrono` crate moves from dev-dependencies to dependencies.

---

## 2. DEVIATIONS FROM REQUIREMENTS

No deviations found. The current codebase is consistent with all prerequisites from prior tickets (SY-13, SY-17). The existing code maps each chat to a single session UUID, which the PRD explicitly calls out as the thing that must change.

---

## 3. Existing Endpoints and Contracts

### 3.1 `TelegramConfig` (synapse-core/src/config.rs, line 142)

```rust
#[derive(Debug, Clone, PartialEq, Deserialize, Default)]
pub struct TelegramConfig {
    pub token: Option<String>,
    pub allowed_users: Vec<u64>,
}
```

**Change required:** Add `max_sessions_per_chat: u32` with `#[serde(default = "default_max_sessions_per_chat")]` defaulting to `10`. The `Default` implementation must also be updated to include this field.

### 3.2 `ChatSessionMap` type alias (synapse-telegram/src/handlers.rs, line 25)

```rust
pub type ChatSessionMap = Arc<RwLock<HashMap<i64, Uuid>>>;
```

**Change required:** Must support multiple sessions per chat with an active session concept. Proposed new structure:

```rust
/// Per-chat session state: list of session UUIDs and the active session index.
#[derive(Debug, Clone)]
pub struct ChatSessions {
    /// All session UUIDs for this chat, ordered by `updated_at` ascending (oldest first).
    pub sessions: Vec<Uuid>,
    /// Index into `sessions` indicating the currently active session.
    pub active: usize,
}

pub type ChatSessionMap = Arc<RwLock<HashMap<i64, ChatSessions>>>;
```

Alternative: `Arc<RwLock<HashMap<i64, Vec<Uuid>>>>` with a separate `Arc<RwLock<HashMap<i64, Uuid>>>` for active tracking. The struct approach is cleaner since it keeps the active session index colocated with the session list.

### 3.3 `resolve_session` (synapse-telegram/src/handlers.rs, line 153)

```rust
async fn resolve_session(
    chat_id: i64,
    config: &Config,
    storage: &Arc<Box<dyn SessionStore>>,
    chat_map: &ChatSessionMap,
) -> anyhow::Result<Uuid> { ... }
```

**Change required:** Must read the active session from `ChatSessions` instead of a single UUID. The "create on first message" logic remains, but it inserts into the `ChatSessions.sessions` vec and sets `active = 0`. The double-check pattern (read lock, then write lock) is preserved.

### 3.4 `rebuild_chat_map` (synapse-telegram/src/main.rs, line 242)

```rust
pub async fn rebuild_chat_map(storage: &dyn SessionStore) -> HashMap<i64, Uuid> {
    let sessions: Vec<SessionSummary> = storage.list_sessions().await.unwrap_or_default();
    sessions
        .into_iter()
        .filter_map(|s| {
            s.name.as_deref()
                .and_then(|n| n.strip_prefix("tg:"))
                .and_then(|id_str| id_str.parse::<i64>().ok())
                .map(|chat_id| (chat_id, s.id))
        })
        .collect()
}
```

**Change required:** Must return `HashMap<i64, ChatSessions>` instead of `HashMap<i64, Uuid>`. Multiple sessions with the same `tg:<chat_id>` name must be grouped. The most recently updated session (first in `list_sessions()` results, which returns `ORDER BY updated_at DESC`) becomes the active session. Since `list_sessions()` returns sessions ordered by `updated_at DESC`, the first session encountered for a chat_id is the most recent and should be set as active.

### 3.5 `handle_message` (synapse-telegram/src/handlers.rs, line 37)

```rust
pub async fn handle_message(
    bot: Bot,
    msg: TgMessage,
    config: Arc<Config>,
    agent: Arc<Agent>,
    storage: Arc<Box<dyn SessionStore>>,
    chat_map: ChatSessionMap,
) -> ResponseResult<()> { ... }
```

**Change required:** This function continues to handle non-command text messages. With the branched dispatcher pattern, commands will be routed to a separate handler before reaching this endpoint. No functional change is needed for `handle_message` itself (it already routes to the active session via `resolve_session`), but the `ChatSessionMap` type it receives will change.

### 3.6 `SessionStore` trait (synapse-core/src/storage.rs)

The existing trait provides all necessary operations for the commands:
- `create_session(&Session)` -- for `/new`
- `list_sessions()` -- for `/list` and `rebuild_chat_map`
- `get_messages(session_id)` -- for `/history`
- `delete_session(id)` -- for `/delete`
- `touch_session(id)` -- for session activity tracking

No changes required to `SessionStore`. The trait already supports everything needed.

### 3.7 `list_sessions()` ordering (synapse-core/src/storage/sqlite.rs, line 181)

```sql
ORDER BY s.updated_at DESC
```

Returns sessions ordered by most recently updated first. This is critical for:
- `/list` display ordering
- 1-based index consistency between `/list` output and `/switch`/`/delete` input
- Determining the "oldest" session for cap eviction (last in the list = oldest `updated_at`)

### 3.8 Dispatcher setup (synapse-telegram/src/main.rs, line 183)

```rust
let handler = Update::filter_message().endpoint(handlers::handle_message);

Dispatcher::builder(bot, handler)
    .dependencies(dptree::deps![
        Arc::clone(&config),
        Arc::clone(&agent),
        Arc::clone(&storage),
        chat_map
    ])
    .enable_ctrlc_handler()
    .build()
    .dispatch()
    .await;
```

**Change required:** Must switch to branched dispatcher:

```rust
let handler = Update::filter_message()
    .branch(dptree::entry().filter_command::<Command>().endpoint(commands::handle_command))
    .branch(dptree::entry().endpoint(handlers::handle_message));
```

The `Me` type must be injected into the dependency map for `filter_command` to parse bot commands correctly (it needs to know the bot's username for commands like `/help@bot_username`):

```rust
let me = bot.get_me().await?;

Dispatcher::builder(bot, handler)
    .dependencies(dptree::deps![
        me,
        Arc::clone(&config),
        Arc::clone(&agent),
        Arc::clone(&storage),
        chat_map
    ])
    ...
```

### 3.9 `set_my_commands` (Telegram Bot API)

Called at startup to register the command list with Telegram for autocomplete:

```rust
bot.set_my_commands(Command::bot_commands()).await?;
```

This is a teloxide Bot API method. If it fails, commands still work but users won't see autocomplete. Per PRD, failure should be logged but not fatal.

---

## 4. Layers and Dependencies

### 4.1 Dependency Flow

```
synapse-telegram (interface crate)
    ├── commands.rs       [NEW] Command enum + 6 handler functions
    ├── handlers.rs       [MODIFIED] ChatSessionMap type change, resolve_session update
    ├── main.rs           [MODIFIED] branched dispatcher, Me injection, rebuild_chat_map multi-session
    └── format.rs         [UNCHANGED]
        │
        ▼
    synapse-core (library crate)
    ├── config.rs         [MODIFIED] TelegramConfig gains max_sessions_per_chat
    ├── storage.rs        [UNCHANGED]
    ├── session.rs        [UNCHANGED]
    └── agent.rs          [UNCHANGED]
```

### 4.2 Crate Dependency Changes

**synapse-telegram/Cargo.toml:**
- `chrono` moves from `[dev-dependencies]` to `[dependencies]` (needed at runtime for timestamp formatting in `/history` and `/list`)

**synapse-core:** No dependency changes needed; `chrono` is already a regular dependency there.

### 4.3 Module Structure

New file: `synapse-telegram/src/commands.rs`
- Must be declared in `main.rs` as `mod commands;`
- Contains the `Command` enum and handler function(s)
- Follows the project's module convention (no `mod.rs` files)

---

## 5. Patterns Used

### 5.1 teloxide BotCommands Derive

The `Command` enum uses `#[derive(BotCommands, Clone)]` from `teloxide::utils::command::BotCommands`. The `macros` feature is already enabled in the teloxide dependency.

```rust
use teloxide::utils::command::BotCommands;

#[derive(BotCommands, Clone)]
#[command(rename_rule = "lowercase", description = "Available commands:")]
enum Command {
    #[command(description = "Show available commands")]
    Help,
    #[command(description = "Start a new session")]
    New,
    #[command(description = "Show conversation history")]
    History,
    #[command(description = "List all sessions")]
    List,
    #[command(description = "Switch to session N")]
    Switch(usize),
    #[command(description = "Delete session N")]
    Delete(usize),
}
```

The `Switch(usize)` and `Delete(usize)` variants accept a single argument parsed from the command text (e.g., `/switch 2` parses to `Command::Switch(2)`).

### 5.2 Branched Dispatcher Pattern

teloxide's `dptree` allows branching message handling:

```rust
let handler = Update::filter_message()
    .branch(dptree::entry().filter_command::<Command>().endpoint(command_handler))
    .branch(dptree::entry().endpoint(message_handler));
```

The first branch tries to parse the message as a command. If parsing succeeds, the `Command` variant is added to the dependency map and the command endpoint handles it. If parsing fails (not a recognized command), the branch is skipped and the second branch handles the message as regular text.

### 5.3 Dependency Injection via dptree

All shared state is injected via `dptree::deps![]` and received as typed function parameters. The command handler will have the same signature pattern as `handle_message`:

```rust
async fn handle_command(
    bot: Bot,
    msg: TgMessage,
    cmd: Command,
    config: Arc<Config>,
    agent: Arc<Agent>,
    storage: Arc<Box<dyn SessionStore>>,
    chat_map: ChatSessionMap,
) -> ResponseResult<()> { ... }
```

### 5.4 Authorization Reuse

The `is_authorized()` function in `handlers.rs` is already public and can be called from the command handler. Authorization must apply to all commands, same as regular messages.

### 5.5 Session Naming Convention

All Telegram sessions use `"tg:<chat_id>"` naming. This convention is preserved for new sessions created via `/new`. The `rebuild_chat_map` function uses this convention to discover sessions.

---

## 6. Detailed Command Implementation Notes

### 6.1 `/help`

Returns `Command::descriptions().to_string()` which teloxide auto-generates from the `#[command(description = "...")]` attributes. Simple, no storage interaction.

### 6.2 `/new`

1. Check session cap: count sessions for this chat in `ChatSessionMap`
2. If at cap (`max_sessions_per_chat`): find oldest session by `updated_at` (last in the list since `list_sessions()` returns DESC), delete it from storage AND from the `ChatSessions.sessions` vec
3. Create a new `Session` with name `"tg:<chat_id>"`
4. Store in DB via `create_session()`
5. Add to `ChatSessions.sessions` and set as active
6. Reply confirming new session created

### 6.3 `/history`

1. Get active session ID from `ChatSessionMap`
2. Call `storage.get_messages(session_id)`
3. Format each message with role label and timestamp using `chrono`
4. Send formatted history (chunked if needed)
5. If no messages, reply "No messages in current session."

### 6.4 `/list`

1. Get `ChatSessions` for this chat from `ChatSessionMap`
2. For each session UUID, need metadata (created_at, updated_at, message_count, preview). Two approaches:
   - **Option A:** Call `list_sessions()` and filter to only sessions in the chat's vec. Wasteful if many CLI sessions exist.
   - **Option B:** Call `get_session()` for each UUID individually. More targeted but N queries.
   - **Option C:** Use `list_sessions()` once and cross-reference with the chat's session UUIDs. Best approach since `list_sessions()` returns summaries with all needed data and is already ordered.
3. Display 1-based index, timestamps, message count, preview
4. Mark the active session with an indicator (e.g., `*` or arrow)

### 6.5 `/switch N`

1. Parse N (1-based index) from command argument
2. Get `ChatSessions` for this chat
3. Validate: N >= 1 and N <= sessions.len()
4. Set `active = N - 1` (convert to 0-based)
5. Touch the session to update `updated_at`
6. Reply confirming switch
7. On invalid index: reply with error suggesting `/list`

**Critical ordering consideration:** The 1-based index must correspond to the order displayed by `/list`. Since `/list` should show sessions in a user-friendly order (most recent first, matching `list_sessions()` DESC ordering), the index N corresponds to that display order. The `ChatSessions.sessions` vec should be maintained in the same order as displayed.

### 6.6 `/delete N`

1. Parse N (1-based index) from command argument
2. Validate index bounds
3. Get the session UUID at index N-1
4. Call `storage.delete_session(id)`
5. Remove from `ChatSessions.sessions` vec
6. If the deleted session was the active one:
   - If other sessions remain: set active to the next most recent (index 0, or adjust if needed)
   - If no sessions remain: auto-create a new session (same as first-message behavior)
7. Reply confirming deletion

---

## 7. `ChatSessionMap` Data Structure Design

### 7.1 Proposed Structure

```rust
#[derive(Debug, Clone)]
pub struct ChatSessions {
    /// Session UUIDs ordered by updated_at DESC (most recent first).
    /// This order matches the 1-based index in /list, /switch, /delete.
    pub sessions: Vec<Uuid>,
    /// Index into `sessions` indicating the currently active session.
    pub active_idx: usize,
}

impl ChatSessions {
    pub fn active_session_id(&self) -> Option<Uuid> {
        self.sessions.get(self.active_idx).copied()
    }
}

pub type ChatSessionMap = Arc<RwLock<HashMap<i64, ChatSessions>>>;
```

### 7.2 Ordering Invariant

The `sessions` vec must be kept in the same order as what `/list` displays. Since `list_sessions()` returns `ORDER BY updated_at DESC`, the vec should also be most-recent-first. This means:
- `/list` index 1 = `sessions[0]` = most recently updated
- `/switch 1` activates `sessions[0]`
- When `/new` creates a session, it inserts at index 0 (it's the most recent)
- When a message is sent to a session, its position in the vec may need re-sorting (or the vec can be refreshed from `list_sessions()` on `/list` to avoid stale ordering)

**Simplification option:** Rather than maintaining perfect ordering in the in-memory vec, the `/list` command can fetch fresh data from `list_sessions()` and cross-reference. The in-memory vec is primarily for tracking which sessions belong to a chat and which is active. The ordering for display can come from the DB each time `/list` is called.

### 7.3 Rebuild from Storage

```rust
pub async fn rebuild_chat_map(storage: &dyn SessionStore) -> HashMap<i64, ChatSessions> {
    let sessions: Vec<SessionSummary> = storage.list_sessions().await.unwrap_or_default();
    let mut map: HashMap<i64, Vec<Uuid>> = HashMap::new();

    // list_sessions() returns ORDER BY updated_at DESC, so first encountered = most recent
    for s in &sessions {
        if let Some(chat_id) = s.name.as_deref()
            .and_then(|n| n.strip_prefix("tg:"))
            .and_then(|id_str| id_str.parse::<i64>().ok())
        {
            map.entry(chat_id).or_default().push(s.id);
        }
    }

    map.into_iter()
        .map(|(chat_id, session_ids)| {
            (chat_id, ChatSessions {
                sessions: session_ids,
                active_idx: 0, // Most recent session is active
            })
        })
        .collect()
}
```

---

## 8. `chrono` Dependency Change

### 8.1 Current State

**synapse-telegram/Cargo.toml:**
```toml
[dev-dependencies]
chrono = "0.4"
```

### 8.2 Required Change

Move to `[dependencies]`:
```toml
[dependencies]
chrono = "0.4"
```

This is needed because `/history` and `/list` format timestamps at runtime (not just in tests). `chrono` is already a regular dependency of `synapse-core`, so no version conflicts.

---

## 9. Config Deserialization

### 9.1 New Field

```rust
#[derive(Debug, Clone, PartialEq, Deserialize, Default)]
pub struct TelegramConfig {
    #[serde(default)]
    pub token: Option<String>,
    #[serde(default)]
    pub allowed_users: Vec<u64>,
    #[serde(default = "default_max_sessions_per_chat")]
    pub max_sessions_per_chat: u32,
}

fn default_max_sessions_per_chat() -> u32 {
    10
}
```

### 9.2 Default Trait Impact

`TelegramConfig` currently derives `Default`. Adding a new field with a serde default of 10 means the `Default` derive will give `max_sessions_per_chat: 0`. This is a problem. Two options:

**Option A:** Implement `Default` manually instead of deriving:
```rust
impl Default for TelegramConfig {
    fn default() -> Self {
        Self {
            token: None,
            allowed_users: vec![],
            max_sessions_per_chat: default_max_sessions_per_chat(),
        }
    }
}
```

**Option B:** Use `#[serde(default)]` on the struct itself and rely on manual Default. Option A is cleaner and consistent with how `SessionConfig` and `LoggingConfig` handle defaults.

### 9.3 Test Additions

- Test parsing `max_sessions_per_chat` from TOML
- Test default value (10) when field is omitted
- Test `TelegramConfig::default()` includes correct `max_sessions_per_chat`

---

## 10. Limitations and Risks

### 10.1 Session Ordering Consistency

The 1-based index in `/switch` and `/delete` depends on a consistent, deterministic ordering. Using `list_sessions()` (which orders by `updated_at DESC`) is the source of truth. However, if a user sends `/list`, then sends a message (updating a session's `updated_at`), the indexes may shift before they send `/switch`. Mitigation: this is acceptable UX for a Telegram bot; the user can re-run `/list` to see updated indexes.

### 10.2 Race Conditions

Multiple rapid commands from the same chat (e.g., `/new` + `/delete` simultaneously) could race on the `ChatSessionMap` write lock. The `RwLock` serializes access within each lock acquisition, but the logic between acquiring read and write locks could see stale data. The existing double-check pattern (read lock, check, write lock, re-check) mitigates this for session creation.

### 10.3 Session Cap Eviction

When evicting the oldest session at cap, the "oldest" is determined by `updated_at`. If the user has been chatting in session A but session B was never used, session B (with an older `updated_at`) gets evicted, which is the correct behavior.

### 10.4 `set_my_commands` Failure

Per PRD: "If it fails, commands still work but users won't see autocomplete suggestions." Implementation should log a warning but not abort startup.

### 10.5 Telegram Message Length for `/history` and `/list`

Long conversation histories or many sessions could exceed 4096 chars. The existing `chunk_message()` utility handles plain text chunking. For HTML-formatted output, `chunk_html()` should be used. For simplicity, `/history` and `/list` can use plain text formatting (no HTML parse mode needed for these informational outputs).

### 10.6 `filter_command` and `Me` Type

teloxide's `filter_command::<Command>()` requires `Me` (the bot's identity) in the dependency map to correctly parse commands that include the bot's username (e.g., `/help@my_bot`). `Me` is obtained via `bot.get_me().await`. This is a network call at startup.

---

## 11. Resolved Questions

**Q: How should the `ChatSessionMap` type be restructured?**
A: Use a `ChatSessions` struct with a `Vec<Uuid>` and an `active_idx: usize` field, wrapped in the existing `Arc<RwLock<HashMap<i64, ChatSessions>>>`. This keeps session list and active pointer colocated.

**Q: What ordering should `/list` use?**
A: Most recently updated first, matching `list_sessions()` SQL ordering (`ORDER BY updated_at DESC`). 1-based index 1 = most recent.

**Q: How should cap eviction work?**
A: Delete the session with the oldest `updated_at` (last in DESC-ordered list) from both storage and the in-memory map.

**Q: Should `/history` and `/list` use HTML formatting?**
A: Plain text is simpler and less error-prone for these informational responses. No parse mode is needed.

---

## 12. New Technical Questions Discovered

None. The teloxide `BotCommands` + `filter_command` + branched dispatcher pattern is well-documented and straightforward. All required `SessionStore` operations already exist.
