# SY-10 Research: CLI REPL (Phase 9)

## 1. Existing Architecture

### CLI Structure (`synapse-cli`)

- **Single file**: `synapse-cli/src/main.rs` (353 lines)
- **Entry**: `#[tokio::main] async fn main()` with `clap` argument parsing
- **Modes**: One-shot (argument/stdin), session subcommands (`sessions list|show|delete`)
- **Session flag**: `--session <uuid>` already exists for continuing sessions in one-shot mode
- **Streaming**: Uses `tokio::select!` with `futures::StreamExt` for token-by-token output + Ctrl+C handling
- **No submodules**: All CLI code is in `main.rs`

### Core Traits Used by CLI

- `LlmProvider::stream()` → `Pin<Box<dyn Stream<Item = Result<StreamEvent, ProviderError>> + Send>>`
- `SessionStore` → `create_session`, `get_session`, `get_messages`, `add_message`, `touch_session`, `cleanup`
- `Config::load()` → config with `provider`, `model`, `api_key`, `session` fields
- `create_provider(&config)` → `Box<dyn LlmProvider>`
- `create_storage(db_url)` → `Box<dyn SessionStore>`

### Key Types

- `Message { role: Role, content: String }`
- `Role { System, User, Assistant }`
- `Session { id: Uuid, name, provider, model, system_prompt, created_at, updated_at }`
- `StoredMessage { id: Uuid, session_id: Uuid, role: Role, content: String, timestamp }`
- `StreamEvent { TextDelta(String), ToolCall, ToolResult, Done, Error(ProviderError) }`

### Dependencies (`synapse-cli/Cargo.toml`)

Current: `anyhow`, `chrono`, `clap` (derive), `synapse-core`, `tokio` (rt-multi-thread, macros, io-std, signal), `futures`, `uuid` (v4).

**Need to add**: `ratatui`, `crossterm` (per PRD requirement).

## 2. Patterns in Use

### Module System
- Rust 2018+ style: `module.rs` + `module/` directory, **no `mod.rs`**
- CLI currently has no submodules — all in `main.rs`

### Error Handling
- `anyhow` in CLI with `.context()` wrapping
- `thiserror` in `synapse-core`
- Propagation with `?` operator

### Streaming Pattern (from `main.rs`)
```rust
let stream = provider.stream(&messages);
tokio::pin!(stream);
loop {
    tokio::select! {
        event = stream.next() => { /* handle TextDelta, Done, Error */ }
        _ = tokio::signal::ctrl_c() => { println!("\n[Interrupted]"); break; }
    }
}
```

### Session Pattern (from `main.rs`)
```rust
// Create or resume session
let (session, history) = if let Some(session_id) = args.session {
    // Load existing session + messages
} else {
    // Create new session
};
// Build message history from StoredMessages → Messages
// Add user message, store it, call provider, store response
```

## 3. Existing Endpoints / Contracts

### CLI Args (`clap` struct)
```rust
struct Args {
    message: Option<String>,           // positional
    #[arg(short, long)] session: Option<Uuid>,  // --session / -s
    #[command(subcommand)] command: Option<Commands>,
}
```

New `--repl` flag must be added here. It needs to coexist with existing `--session` and subcommands.

### Config (`Config` struct)
- `provider: String`, `api_key: Option<String>`, `model: String`
- `session: Option<SessionConfig>` with `database_url`, `max_sessions`, `retention_days`, `auto_cleanup`

## 4. Integration Points for REPL

### Input Loop
- REPL needs a **read** → **eval** → **print** → **loop** cycle
- `ratatui` with `crossterm` backend provides terminal UI rendering
- `crossterm` handles raw mode, event reading (key presses), terminal size
- Must integrate with `tokio` async runtime for streaming responses

### Terminal Management
- Enter raw mode on REPL start, restore on exit
- `crossterm::terminal::enable_raw_mode()` / `disable_raw_mode()`
- `ratatui::Terminal::new(CrosstermBackend::new(stdout))` for UI rendering
- **Critical**: Must clean up terminal on all exit paths (normal, error, panic)
- Use `Drop` guard pattern or `std::panic::set_hook` for cleanup

### Session Integration
- New REPL session: `Session::new(&config.provider, &config.model)` + `storage.create_session(&session)`
- Resume: `storage.get_session(id)` + `storage.get_messages(session_id)`
- Each turn: `storage.add_message(user_msg)` → `provider.stream(&messages)` → `storage.add_message(assistant_msg)`
- `storage.touch_session(session.id)` on each interaction

### Streaming in TUI
- Provider returns `Stream<Item = Result<StreamEvent, ProviderError>>`
- Must render `TextDelta` tokens as they arrive into a `ratatui` widget
- Need to handle concurrent: key events from crossterm + stream events from provider
- `tokio::select!` pattern works here

## 5. ratatui + crossterm Architecture

### Key Components

**Terminal setup**:
```
crossterm::terminal::enable_raw_mode()
crossterm::execute!(stdout, EnterAlternateScreen)
Terminal::new(CrosstermBackend::new(stdout))
```

**Event loop** (integrated with tokio):
```
crossterm::event::EventStream (async key events)
tokio::select! {
    key_event = event_stream.next() => { /* handle input */ }
    stream_event = llm_stream.next() => { /* handle token */ }
}
```

**UI Layout** (ratatui widgets):
- `Paragraph` for conversation history (scrollable)
- `Paragraph` or custom widget for input area
- `Block` for borders/titles
- `Layout` for splitting terminal into areas

**Cleanup**:
```
crossterm::terminal::disable_raw_mode()
crossterm::execute!(stdout, LeaveAlternateScreen)
```

## 6. Limitations and Risks

1. **Terminal corruption**: If cleanup fails, terminal stays in raw mode. Mitigation: `Drop` guard.
2. **ratatui complexity**: Full TUI framework for what could be a simple line-based REPL. However, it provides scrollable history, proper layout, and future extensibility (status bar, model info, etc.).
3. **Async event integration**: `crossterm::event::EventStream` requires the `event-stream` feature on crossterm. This creates a stream of terminal events that integrates naturally with `tokio::select!`.
4. **Input editing**: Raw mode means no line editing by default. Need to handle backspace, arrow keys, etc. manually or via ratatui's input widget.
5. **Multi-line input**: Users may want to paste multi-line content. Need to decide on handling.

## 7. New File Structure

Per PRD task 9.2, create `synapse-cli/src/repl.rs`:

```
synapse-cli/src/
├── main.rs       # existing: add `mod repl;`, add `--repl` flag
└── repl.rs       # new: REPL implementation
```

## 8. Resolved Questions

- **User preferences**: Use defaults per documented requirements.
- **ratatui + crossterm**: Required by PRD and CLAUDE.md technology decisions.
- **Module path**: `synapse-cli/src/repl.rs` per task 9.2.
- **Flag**: `--repl` per task 9.3.
- **Session resume**: `--repl --session <id>` per task 9.4.

## 9. Technical Questions Discovered

1. **crossterm `event-stream` feature**: Required for async event reading. Must add `crossterm` with `event-stream` feature.
2. **Input editing experience**: How sophisticated should the input line be? Basic (backspace only) vs. full line editing (cursor movement, home/end, etc.)?
3. **Conversation display**: Scrollable history with role labels? How to handle long responses that exceed terminal height?
4. **REPL commands**: PRD mentions `/quit`. Should other REPL-specific commands be supported (e.g., `/clear`, `/new`, `/sessions`)?

## 10. Deviations from Requirements

**None found.** The existing codebase aligns with all PRD requirements:
- `--session` flag already exists and can be combined with new `--repl` flag
- Session storage infrastructure is complete
- Streaming infrastructure is complete
- Module system follows conventions
