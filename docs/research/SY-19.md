# SY-19 Research: Telegram Command Fixes & Interactive Keyboards

## 1. Existing Endpoints and Contracts

### Command Enum (commands.rs:18-39)

The current `Command` enum uses `BotCommands` derive and defines six variants:

```rust
pub enum Command {
    Help,
    New,
    History,
    List,
    Switch(usize),
    Delete(usize),
}
```

**Root cause of the fall-through bug:** `Switch(usize)` and `Delete(usize)` fail teloxide's `BotCommands::parse` when no argument is provided because `usize::from_str("")` returns an error. Since `filter_command` uses `.ok()` internally, the parse error becomes `None`, causing the entire command branch to be rejected. The message then falls through to `handle_message`, which forwards it to the LLM.

### Dispatcher (main.rs:194-200)

Currently message-only, no callback query handling:

```rust
let handler = Update::filter_message()
    .branch(
        dptree::entry()
            .filter_command::<commands::Command>()
            .endpoint(commands::handle_command),
    )
    .branch(dptree::entry().endpoint(handlers::handle_message));
```

### handle_message (handlers.rs:57-167)

No defensive guard exists. Any text starting with `/` that `filter_command` fails to parse is forwarded directly to the LLM via `agent.complete()`.

### handle_command (commands.rs:44-71)

Dispatches to private handler functions. The match arms for `Switch` and `Delete` pass the `usize` argument directly:

```rust
Command::Switch(n) => cmd_switch(&bot, &msg, n, &storage, &chat_map).await,
Command::Delete(n) => cmd_delete(&bot, &msg, n, &config, &storage, &chat_map).await,
```

### cmd_switch / cmd_delete (commands.rs:266-408)

Both follow the same pattern:
1. Read `chat_map` to get session UUIDs for the chat.
2. Call `storage.list_sessions()` and filter to the chat's sessions (DB ordering = `updated_at DESC`).
3. Validate the 1-based index `n`.
4. Execute the action (update `active_idx` / delete from DB and `chat_map`).
5. Reply with a confirmation string.

The core logic (steps 1-4) is currently inlined. The PRD requires extracting it into `do_switch()` and `do_delete()` returning `String` so that both the slash-command and callback paths can share the same implementation.

## 2. Layers and Dependencies

### Dependency Flow

```
main.rs
  ├── commands.rs (handle_command, handle_callback)
  │     └── uses: Bot, TgMessage/CallbackQuery, Config, SessionStore, ChatSessionMap
  ├── handlers.rs (handle_message, ChatSessions, ChatSessionMap, is_authorized, chunk_message)
  │     └── uses: Bot, TgMessage, Config, Agent, SessionStore, ChatSessionMap
  └── format.rs (md_to_telegram_html, chunk_html, escape_html)
```

### dptree Dependency Injection

The existing `dptree::deps![]` supplies:
- `me` (bot identity, for `filter_command` username stripping)
- `Arc<Config>`
- `Arc<Agent>`
- `Arc<Box<dyn SessionStore>>`
- `ChatSessionMap`

The new `handle_callback` endpoint will receive `CallbackQuery` (injected by `Update::filter_callback_query()`) plus the same shared deps (Config, SessionStore, ChatSessionMap). It does NOT need `Agent` since callbacks are pure session management.

### Crate Dependencies

`synapse-telegram/Cargo.toml` already includes:
- `teloxide = { version = "0.17.0", features = ["macros"] }` -- provides `InlineKeyboardMarkup`, `InlineKeyboardButton`, `CallbackQuery`, `ReplyMarkup`, `BotMessagesExt` sugar
- `uuid`, `chrono`, `anyhow`, `tracing`

No new crate dependencies are needed.

## 3. Patterns Used

### Branched Dispatcher Pattern

teloxide 0.17 uses `dptree` for a chain-of-responsibility pattern. `Update::filter_message()` extracts `Message` from the update; `Update::filter_callback_query()` extracts `CallbackQuery`. These are chained via `dptree::entry().branch(...)`.

The teloxide `examples/buttons.rs` demonstrates the exact pattern needed:

```rust
let handler = dptree::entry()
    .branch(Update::filter_message().endpoint(message_handler))
    .branch(Update::filter_callback_query().endpoint(callback_handler));
```

### Inline Keyboard Construction

```rust
// Create button with callback data (1-64 bytes)
InlineKeyboardButton::callback("Button text", "callback_data_string")

// Build keyboard (each inner vec = one row)
InlineKeyboardMarkup::new(vec![
    vec![InlineKeyboardButton::callback("Row 1 Button", "data1")],
    vec![InlineKeyboardButton::callback("Row 2 Button", "data2")],
])
```

### Sending Message with Keyboard

```rust
use teloxide::payloads::SendMessageSetters;

bot.send_message(chat_id, "Select a session:")
    .reply_markup(keyboard)  // InlineKeyboardMarkup implements Into<ReplyMarkup>
    .await?;
```

### Callback Query Handling

```rust
async fn callback_handler(bot: Bot, q: CallbackQuery) -> ResponseResult<()> {
    // 1. Answer immediately to dismiss the loading spinner.
    bot.answer_callback_query(q.id.clone()).await?;

    // 2. Extract callback data.
    if let Some(data) = q.data { /* parse "switch:N" or "delete:N" */ }

    // 3. Edit the keyboard message to plain text (removes keyboard).
    if let Some(message) = q.regular_message() {
        bot.edit_text(message, "Action completed.").await?;
    }
}
```

The `bot.edit_text(message, text)` sugar method (from `teloxide::sugar::bot::BotMessagesExt`) is equivalent to `bot.edit_message_text(message.chat.id, message.id, text)`. Editing replaces the keyboard message content (including removing the inline keyboard), preventing double-taps.

### Authorization Pattern

`is_authorized(user_id, allowed_users)` is defined in `handlers.rs` and imported in `commands.rs`. The callback handler needs the same authorization check. The user ID comes from `q.from.id.0` (analogous to `msg.from.as_ref().map(|u| u.id.0)`).

### Session List Reconstruction

Both `cmd_switch` and `cmd_delete` reconstruct the display-order session list by:
1. Reading `chat_map` to get session UUIDs.
2. Calling `storage.list_sessions()` for all sessions.
3. Filtering to only the chat's sessions (preserves DB `updated_at DESC` ordering).

This pattern will be reused in `do_switch()`, `do_delete()`, and `build_session_keyboard()`.

## 4. teloxide API Details

### Key Types (teloxide-core 0.13.0)

- **`InlineKeyboardMarkup`**: `{ inline_keyboard: Vec<Vec<InlineKeyboardButton>> }`. Methods: `new()`, `append_row()`, `append_to_row()`. Derives `Default`.
- **`InlineKeyboardButton`**: `{ text: String, kind: InlineKeyboardButtonKind }`. Constructor `InlineKeyboardButton::callback(text, callback_data)` creates a button with `CallbackData(String)` kind.
- **`CallbackQuery`**: `{ id: CallbackQueryId, from: User, message: Option<MaybeInaccessibleMessage>, data: Option<String>, ... }`. The `regular_message()` method returns `Option<&Message>`.
- **`CallbackQueryId`**: Newtype wrapper around `String`. `bot.answer_callback_query(q.id)` takes this directly.
- **`MaybeInaccessibleMessage`**: Enum with `Inaccessible` and `Regular(Box<Message>)` variants.
- **`ReplyMarkup`**: Enum. `InlineKeyboardMarkup` implements `Into<ReplyMarkup>` via `derive_more::From`.

### Key Bot Methods

- `bot.answer_callback_query(callback_query_id)` -- required parameter: `CallbackQueryId`. Optional: `text`, `show_alert`, `url`, `cache_time`.
- `bot.edit_message_text(chat_id, message_id, text)` -- edits message text. The `BotMessagesExt::edit_text(&message, text)` sugar wraps this.
- `bot.send_message(chat_id, text).reply_markup(keyboard)` -- sends message with inline keyboard attached.

### Important: `BotMessagesExt` Import

To use `bot.edit_text(message, text)`, the trait must be imported:
```rust
use teloxide::sugar::bot::BotMessagesExt;
```

Alternatively, use the direct API: `bot.edit_message_text(message.chat.id, message.id, text)`.

## 5. Implementation Plan per Task

### Task 19.1: Change Command Enum Types

- Change `Switch(usize)` to `Switch(String)` and `Delete(usize)` to `Delete(String)`.
- Add `parse_session_arg(arg: &str) -> Result<Option<usize>, String>`:
  - Empty string -> `Ok(None)` (show keyboard).
  - Numeric string -> `Ok(Some(n))` (direct execution).
  - Non-numeric, non-empty -> `Err("hint message")`.
- Update `handle_command` match arms: `Command::Switch(ref arg)` and `Command::Delete(ref arg)`.
- `cmd_switch` and `cmd_delete` call `parse_session_arg` and branch on the result.

### Task 19.2: Add Start Variant

- Add `Start` variant to `Command` enum with `#[command(description = "Start the bot")]`.
- Add match arm in `handle_command` dispatching to a welcome message handler.
- Welcome message content: brief description of the bot and available commands.

### Task 19.3: Defensive Guard

- In `handle_message`, after extracting `text`, check if it starts with `/`.
- If it does, reply with "I didn't understand that command. Use /help to see available commands." and return early.
- This catches any command-like message that `filter_command` failed to parse, preventing LLM forwarding.

### Task 19.4: Build Keyboard Functions

- `build_session_keyboard(action: &str, sessions: &[&SessionSummary], active_id: Option<Uuid>) -> InlineKeyboardMarkup`:
  - Creates one button per session as a single row.
  - Button text: `"N. [*] YYYY-MM-DD | M msgs | Preview..."` (matching `/list` format).
  - Callback data: `"switch:N"` or `"delete:N"` (1-based index).
- `cmd_switch_keyboard(bot, msg, storage, chat_map)` -- called when `parse_session_arg` returns `Ok(None)`.
- `cmd_delete_keyboard(bot, msg, storage, chat_map)` -- called when `parse_session_arg` returns `Ok(None)`.

### Task 19.5: Callback Handler and Shared Logic

- Extract `do_switch(n, chat_id, storage, chat_map) -> Result<String, String>`:
  - Contains the core logic from current `cmd_switch` (session list reconstruction, index validation, `active_idx` update).
  - Returns the reply string on success, error string on failure.
- Extract `do_delete(n, chat_id, config, storage, chat_map) -> Result<String, String>`:
  - Contains the core logic from current `cmd_delete`.
  - Returns the reply string.
- `handle_callback(bot, q, config, storage, chat_map) -> ResponseResult<()>`:
  1. Authorization check via `q.from.id.0`.
  2. `bot.answer_callback_query(q.id.clone()).await` immediately.
  3. Parse `q.data` -- expect `"switch:N"` or `"delete:N"`.
  4. Call `do_switch` or `do_delete`.
  5. Edit the keyboard message to the result text via `bot.edit_text(message, result)`.
  6. Log and swallow `edit_text` failures (the action already succeeded).

### Task 19.6: Dispatcher Restructure

Change the handler tree from:
```rust
let handler = Update::filter_message()
    .branch(...)
    .branch(...);
```
To:
```rust
let handler = dptree::entry()
    .branch(Update::filter_message()
        .branch(filter_command -> handle_command)
        .branch(handle_message))
    .branch(Update::filter_callback_query()
        .endpoint(commands::handle_callback));
```

### Task 19.7: Unit Tests

- `test_parse_session_arg_empty` -- returns `Ok(None)`.
- `test_parse_session_arg_numeric` -- returns `Ok(Some(n))`.
- `test_parse_session_arg_non_numeric` -- returns `Err(hint)`.
- `test_parse_session_arg_zero` -- returns `Ok(Some(0))` (validated later by `do_switch`/`do_delete`).
- `test_build_session_keyboard_callback_data` -- verify data format `"action:N"`.
- `test_build_session_keyboard_active_marker` -- verify `*` in active session label.
- `test_build_session_keyboard_empty` -- verify behavior with no sessions.
- `test_defensive_guard_slash_not_forwarded` -- verify command-like text is caught (logic test on the guard condition).

## 6. Limitations and Risks

### Callback Data Staleness (Risk from PRD)

Between the keyboard being shown and the user tapping a button, sessions may be created/deleted, making the 1-based index stale. **Mitigation**: `do_switch` and `do_delete` re-fetch the session list from the DB and validate the index, returning an error if invalid. The callback handler edits the message to display the error.

### Telegram API Rate Limits

Editing messages and answering callback queries count against rate limits. **Mitigation**: These are low-frequency user-initiated actions, well under Telegram's limits.

### `edit_message_text` Failure

If the message is too old (48h for non-inline) or was already deleted, `edit_text` will fail. **Mitigation**: Log the error at `warn` level but do not propagate -- the action already succeeded. The user sees the callback answer notification.

### `CallbackQuery.message` Is `None`

If the callback query originated from an inline message (not a bot-sent message), `q.regular_message()` returns `None`. In our case, the bot always sends the keyboard message itself, so `regular_message()` should always be `Some`. However, the code must handle `None` gracefully -- log and skip the edit.

### Keyboard Button Text Length

Telegram limits inline keyboard button text. Session preview + metadata should be truncated to fit. The existing `/list` format already truncates preview to 40 chars; the keyboard button text will be shorter but should still be capped at a reasonable length.

## 7. Resolved Questions

No open questions in the PRD. The phase-19 document provides comprehensive specifications for all tasks.

## 8. New Technical Questions Discovered

1. **`bot.edit_text` vs `bot.edit_message_text`**: The `edit_text` sugar from `BotMessagesExt` requires importing `teloxide::sugar::bot::BotMessagesExt`. The alternative is the direct `bot.edit_message_text(chat_id, message_id, text)`. Either works; the sugar is cleaner when you already have a `&Message` reference.

2. **`answer_callback_query` parameter type**: The method takes `CallbackQueryId` (a newtype wrapper `CallbackQueryId(String)`). The field `q.id` is already `CallbackQueryId`, so passing `q.id.clone()` is correct. Note: `clone()` is needed because `q` is borrowed later for `q.regular_message()`.

3. **Authorization for callbacks**: `CallbackQuery.from` is a `User` (not `Option<User>` like in `Message`), so `q.from.id.0` is always available -- no need for `as_ref().map()` unwrapping.

## 9. Deviations from Requirements

None identified. The existing code aligns with the requirements -- it simply lacks the features described in the PRD. The `Switch(usize)` / `Delete(usize)` types are the root cause of the bug, and changing them to `String` is the correct fix as specified.
