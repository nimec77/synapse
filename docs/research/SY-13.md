# SY-13 Research: Phase 12 -- Telegram Bot

## 1. Overview

This document captures the technical research for SY-13: Phase 12 -- Telegram Bot. The ticket introduces the **second interface** for Synapse -- a Telegram bot -- proving that the hexagonal architecture works as intended: multiple frontends sharing the same `synapse-core` Agent orchestrator, SessionStore, and MCP subsystems without duplicating business logic.

The `synapse-telegram` crate already exists as a placeholder (created in SY-1) with an empty `main.rs` and no dependencies. This phase brings it to life using `teloxide`, wiring it to the core Agent, SessionStore, and MCP subsystems.

**Key deliverables:**
- 12.1 Add `teloxide` to `synapse-telegram`
- 12.2 Create bot initialization with token from config
- 12.3 Implement message handler using `synapse-core` Agent
- 12.4 Add session-per-chat persistence
- 12.5 Add user authorization via `allowed_users` allowlist

---

## 2. Existing Endpoints and Contracts

### 2.1 synapse-telegram Crate (Current State)

**File:** `/Users/comrade77/RustroverProjects/synapse/synapse-telegram/Cargo.toml`

```toml
[package]
name = "synapse-telegram"
version = "0.1.0"
edition.workspace = true

[[bin]]
name = "synapse-telegram"
path = "src/main.rs"

[dependencies]
# No dependencies for Phase 1
```

**File:** `/Users/comrade77/RustroverProjects/synapse/synapse-telegram/src/main.rs`

```rust
fn main() {
    println!("Synapse Telegram Bot");
}
```

**Observations:**
- The crate is an empty shell. It has no dependencies, no async runtime, and a synchronous `main()`.
- It is already registered in the workspace `Cargo.toml` as a member.
- The binary name is `synapse-telegram` (distinct from `synapse` for the CLI).

### 2.2 Config Struct

**File:** `/Users/comrade77/RustroverProjects/synapse/synapse-core/src/config.rs`

```rust
pub struct Config {
    pub provider: String,
    pub api_key: Option<String>,
    pub model: String,
    pub session: Option<SessionConfig>,
    pub mcp: Option<McpSettings>,
}
```

**Observations:**
- No `telegram` section exists. Per PRD constraints, `TelegramConfig` must be added to `Config` as an optional section since the config struct is shared across interfaces.
- The required structure per PRD:

```rust
pub struct TelegramConfig {
    pub token: Option<String>,
    pub allowed_users: Vec<u64>,
}
```

- Corresponding TOML:

```toml
[telegram]
token = "..."
allowed_users = [123456789, 987654321]
```

### 2.3 Agent Struct

**File:** `/Users/comrade77/RustroverProjects/synapse/synapse-core/src/agent.rs`

```rust
pub struct Agent {
    provider: Box<dyn LlmProvider>,
    mcp_client: Option<McpClient>,
}

impl Agent {
    pub fn new(provider: Box<dyn LlmProvider>, mcp_client: Option<McpClient>) -> Self;
    pub async fn complete(&self, messages: &mut Vec<Message>) -> Result<Message, AgentError>;
    pub fn stream<'a>(&'a self, messages: &'a mut Vec<Message>)
        -> Pin<Box<dyn Stream<Item = Result<StreamEvent, AgentError>> + Send + 'a>>;
    pub fn stream_owned(&self, mut messages: Vec<Message>)
        -> Pin<Box<dyn Stream<Item = Result<StreamEvent, AgentError>> + Send + '_>>;
    pub async fn shutdown(self);
}
```

**Observations:**
- The `Agent` struct is the primary entry point for LLM interaction. Both `complete()` and `stream_owned()` are suitable for the Telegram bot.
- `complete()` returns a single `Message` (synchronous-style, handles tool call loop internally) -- ideal for Telegram where we need the full response before sending.
- `stream_owned()` takes ownership of the messages vec, avoiding borrow issues in async handlers -- this is the preferred method for Telegram to avoid lifetime complexity.
- `Agent` requires a `Box<dyn LlmProvider>` and `Option<McpClient>`. Both are constructed from the shared `Config`.
- `Agent` is **not** `Clone`. For teloxide's `Dispatcher` dependency injection, `Agent` must be wrapped in `Arc<Agent>`. This is valid because `Agent` only holds a `Box<dyn LlmProvider>` (which is `Send + Sync`) and an `Option<McpClient>`.
- `shutdown(self)` takes ownership, which complicates `Arc<Agent>`. The bot will need to handle shutdown via `Arc::try_unwrap()` or skip explicit shutdown (letting drop handle it).

### 2.4 SessionStore Trait

**File:** `/Users/comrade77/RustroverProjects/synapse/synapse-core/src/storage.rs`

```rust
#[async_trait]
pub trait SessionStore: Send + Sync {
    async fn create_session(&self, session: &Session) -> Result<(), StorageError>;
    async fn get_session(&self, id: Uuid) -> Result<Option<Session>, StorageError>;
    async fn list_sessions(&self) -> Result<Vec<SessionSummary>, StorageError>;
    async fn touch_session(&self, id: Uuid) -> Result<(), StorageError>;
    async fn delete_session(&self, id: Uuid) -> Result<bool, StorageError>;
    async fn add_message(&self, message: &StoredMessage) -> Result<(), StorageError>;
    async fn get_messages(&self, session_id: Uuid) -> Result<Vec<StoredMessage>, StorageError>;
    async fn cleanup(&self, config: &SessionConfig) -> Result<CleanupResult, StorageError>;
}
```

**Observations:**
- `SessionStore` is `Send + Sync`, so wrapping `Box<dyn SessionStore>` in `Arc` is valid.
- The session-per-chat mapping requires a way to find an existing session by Telegram chat ID. The current trait has `get_session(Uuid)` but no "find by external ID" method.
- **Design options for chat-to-session mapping:**
  - **Option A:** Add a `chat_id` field to `Session` and a `get_session_by_chat_id()` method to `SessionStore`. This modifies core code (violates constraint 1: "synapse-core must not be modified for Telegram-specific logic").
  - **Option B:** Use session `name` field to store the Telegram chat ID (e.g., `name = Some("telegram:123456789")`), then find it via `list_sessions()` filtering. Workable but inefficient for many sessions.
  - **Option C:** Maintain a separate in-memory `HashMap<i64, Uuid>` (chat_id -> session_id) in `synapse-telegram`, with a lookup table that persists via the session name convention. On startup, iterate `list_sessions()` to rebuild the map.
  - **Option D:** Store the mapping in a separate SQLite table or file in `synapse-telegram` (Telegram-specific persistence).

  The most pragmatic approach is **Option C**: use `Session.name` with a convention like `"tg:<chat_id>"` and maintain an in-memory lookup map. This avoids modifying `synapse-core` while providing O(1) lookups during operation and simple reconstruction on restart.

### 2.5 Provider Factory

**File:** `/Users/comrade77/RustroverProjects/synapse/synapse-core/src/provider/factory.rs`

```rust
pub fn create_provider(config: &Config) -> Result<Box<dyn LlmProvider>, ProviderError>
```

**Observations:**
- The same factory function used by the CLI can be used by the Telegram bot. No changes needed.

### 2.6 Storage Factory

**File:** `/Users/comrade77/RustroverProjects/synapse/synapse-core/src/storage/sqlite.rs`

```rust
pub async fn create_storage(config_database_url: Option<&str>) -> Result<Box<dyn SessionStore>, StorageError>
```

**Observations:**
- The same factory function used by the CLI can be used by the Telegram bot. The SQLite WAL mode already supports concurrent access from multiple processes.

### 2.7 MCP Client

**File:** `/Users/comrade77/RustroverProjects/synapse/synapse-core/src/mcp/tools.rs`

```rust
pub struct McpClient { ... }

impl McpClient {
    pub async fn new(config: &McpConfig) -> Result<Self, McpError>;
    pub fn has_tools(&self) -> bool;
    pub async fn call_tool(&self, name: &str, input: Value) -> Result<Value, McpError>;
    pub async fn shutdown(self);
}
```

**Observations:**
- `McpClient` is **not** `Clone` or `Sync`. It holds `RunningService` instances which involve async channels.
- The `Agent` struct takes `Option<McpClient>` by value. Since `McpClient` is consumed by `Agent::new()`, and the Agent will be wrapped in `Arc`, there's no issue -- tool calls go through `&self` methods on `Agent`.

### 2.8 Message and Session Types

**File:** `/Users/comrade77/RustroverProjects/synapse/synapse-core/src/message.rs`

```rust
pub struct Message {
    pub role: Role,
    pub content: String,
    pub tool_calls: Option<Vec<ToolCallData>>,
    pub tool_call_id: Option<String>,
}
```

**File:** `/Users/comrade77/RustroverProjects/synapse/synapse-core/src/session.rs`

```rust
pub struct Session {
    pub id: Uuid,
    pub name: Option<String>,
    pub provider: String,
    pub model: String,
    pub system_prompt: Option<String>,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

pub struct StoredMessage {
    pub id: Uuid,
    pub session_id: Uuid,
    pub role: Role,
    pub content: String,
    pub tool_calls: Option<String>,
    pub tool_results: Option<String>,
    pub timestamp: DateTime<Utc>,
}
```

**Observations:**
- `Message::new(Role::User, text)` is the standard way to create user messages. The Telegram bot will use this.
- `StoredMessage::new(session_id, Role::User, text)` is used for persistence.
- `Session::new(provider, model).with_name(name)` is how sessions are created.

### 2.9 CLI Integration Pattern (Reference)

**File:** `/Users/comrade77/RustroverProjects/synapse/synapse-cli/src/main.rs`

The CLI demonstrates the full integration pattern:

```rust
// 1. Load config
let config = Config::load().unwrap_or_default();

// 2. Create storage
let session_config = config.session.clone().unwrap_or_default();
let storage = create_storage(session_config.database_url.as_deref()).await?;

// 3. Auto-cleanup
if session_config.auto_cleanup {
    let _ = storage.cleanup(&session_config).await;
}

// 4. Create provider
let provider = create_provider(&config)?;

// 5. Initialize MCP
let mcp_path = config.mcp.as_ref().and_then(|m| m.config_path.as_deref());
let mcp_client = init_mcp_client(mcp_path).await;

// 6. Create agent
let agent = Agent::new(provider, mcp_client);

// 7. Create/load session
let session = Session::new(&config.provider, &config.model);
storage.create_session(&session).await?;

// 8. Build messages, call agent, store response
```

The Telegram bot must follow the same pattern, with the key difference that it manages multiple concurrent sessions (one per chat).

### 2.10 Public Exports

**File:** `/Users/comrade77/RustroverProjects/synapse/synapse-core/src/lib.rs`

```rust
pub use agent::{Agent, AgentError};
pub use config::{Config, ConfigError, McpSettings, SessionConfig};
pub use mcp::{McpClient, McpConfig, McpError, McpServerConfig, ToolDefinition, load_mcp_config};
pub use message::{Message, Role, ToolCallData};
pub use provider::{..., create_provider};
pub use session::{Session, SessionSummary, StoredMessage};
pub use storage::{CleanupResult, SessionStore, SqliteStore, StorageError, create_storage};
```

All the types needed by the Telegram bot are publicly exported from `synapse-core`.

---

## 3. Layers and Dependencies

### 3.1 Current Dependency Graph

```
synapse-cli          (anyhow, clap, ratatui, crossterm, futures, tokio, uuid, chrono)
    |
    v
synapse-core         (thiserror, reqwest, sqlx, serde, serde_json, tokio, async-stream,
    |                  eventsource-stream, uuid, chrono, dirs, toml, rmcp, async-trait, futures)
    +-- agent.rs
    +-- provider/     (Anthropic, DeepSeek, OpenAI, Mock)
    +-- storage/      (SqliteStore)
    +-- mcp/          (McpClient, McpConfig, ToolDefinition)
    +-- config.rs     (Config, SessionConfig, McpSettings)
    +-- message.rs    (Message, Role, ToolCallData)
    +-- session.rs    (Session, SessionSummary, StoredMessage)

synapse-telegram     (EMPTY - placeholder)
```

### 3.2 New Dependencies for synapse-telegram

| Crate | Features | Purpose |
|-------|----------|---------|
| `teloxide` | `macros`, `ctrlc_handler` (default) | Telegram Bot API framework |
| `synapse-core` | (path dependency) | Core library |
| `tokio` | `rt-multi-thread`, `macros` | Async runtime |
| `anyhow` | -- | Application-level error handling |
| `futures` | -- | Stream utilities |
| `uuid` | `v4` | UUID operations |
| `tracing` | -- | Structured logging |
| `tracing-subscriber` | -- | Log output |

### 3.3 New Module Structure for synapse-telegram

Per the vision document (Section 3), the Telegram crate should have:

```
synapse-telegram/src/
    main.rs            # Bot entry point, initialization
    handlers.rs        # Message handlers (authorized message handling, session management)
```

The `keyboard.rs` file mentioned in the vision document can be deferred -- it's for inline keyboards which are beyond the current ticket scope.

### 3.4 Config Change in synapse-core

A single modification to `synapse-core/src/config.rs` is required: adding the `TelegramConfig` struct and an optional `telegram` field to `Config`. Per PRD constraint 2: "TelegramConfig must live in `synapse-core/src/config.rs` as an optional section of Config."

```rust
// Addition to Config struct:
pub struct Config {
    // ... existing fields ...
    pub telegram: Option<TelegramConfig>,
}

#[derive(Debug, Clone, PartialEq, Deserialize)]
pub struct TelegramConfig {
    pub token: Option<String>,
    #[serde(default)]
    pub allowed_users: Vec<u64>,
}
```

This is the **only** change to `synapse-core` required for this ticket. It is not Telegram-specific logic -- it is configuration parsing, which is the config module's responsibility.

---

## 4. Patterns Used

### 4.1 Hexagonal Architecture

The Telegram bot is a new **driving adapter** (interface) in the hexagonal architecture. It uses the same ports (traits) as the CLI:

```
synapse-telegram  -----> Agent (orchestrator)
                            |
                  +---------+----------+
                  v         v          v
              LlmProvider  SessionStore  McpClient
              (trait)      (trait)
                  |         |
                  v         v
              Anthropic    SqliteStore
              DeepSeek
              Mock
```

### 4.2 teloxide Dispatcher Pattern

teloxide uses a `Dispatcher` with `dptree` for dependency injection and message routing:

```rust
let handler = Update::filter_message().endpoint(handle_message);

Dispatcher::builder(bot, handler)
    .dependencies(dptree::deps![config, agent, storage])
    .enable_ctrlc_handler()
    .build()
    .dispatch()
    .await;
```

Dependencies injected via `dptree::deps![]` become available to handler functions by type. The handler receives them as function parameters:

```rust
async fn handle_message(
    bot: Bot,
    msg: Message,
    config: Arc<Config>,
    agent: Arc<Agent>,
    storage: Arc<Box<dyn SessionStore>>,
) -> ResponseResult<()> {
    // ...
}
```

### 4.3 Shared State with Arc

teloxide's dependency injection system requires `Clone` for injected dependencies. Since `Agent` and `Box<dyn SessionStore>` are not `Clone`, they must be wrapped in `Arc`:

- `Arc<Config>` -- config is read-only, `Arc` is sufficient
- `Arc<Agent>` -- Agent's methods take `&self`, `Arc` works
- `Arc<Box<dyn SessionStore>>` -- SessionStore's methods take `&self`, `Arc` works
- Chat-to-session map: `Arc<tokio::sync::RwLock<HashMap<i64, Uuid>>>` -- needs interior mutability for concurrent chat access

### 4.4 Error Handling

Per conventions: `synapse-telegram` uses `anyhow` for application-level errors (consistent with `synapse-cli`). teloxide's handler return type is `ResponseResult<()>` which is `Result<(), Box<dyn Error + Send + Sync>>`.

### 4.5 Bot Token Resolution

Following the established env-var-over-config pattern:

```rust
fn resolve_bot_token(config: &Config) -> Result<String> {
    // Priority 1: Environment variable
    if let Ok(token) = std::env::var("TELEGRAM_BOT_TOKEN") {
        if !token.is_empty() {
            return Ok(token);
        }
    }
    // Priority 2: Config file
    config.telegram.as_ref()
        .and_then(|t| t.token.clone())
        .ok_or_else(|| anyhow!("Bot token required: set TELEGRAM_BOT_TOKEN or telegram.token in config"))
}
```

---

## 5. teloxide Library Analysis

### 5.1 Version and Compatibility

- **Latest version:** 0.17.0 (published July 11, 2025)
- **Key dependencies:** `tokio ^1.39`, `serde ^1.0`, `futures ^0.3.15`, `thiserror ^2.0.11`
- **Rust toolchain:** The project uses nightly (via `rust-toolchain.toml`). teloxide supports nightly Rust.
- **TLS:** Defaults to `native-tls`. Can switch to `rustls` via feature flag. The default is fine for this project.

### 5.2 Bot Creation

```rust
use teloxide::prelude::*;

// From environment variable (TELOXIDE_TOKEN)
let bot = Bot::from_env();

// From explicit token
let bot = Bot::new("bot_token_here");
```

Note: `Bot::from_env()` reads `TELOXIDE_TOKEN` by default. Since the PRD specifies `TELEGRAM_BOT_TOKEN`, we should resolve the token ourselves and use `Bot::new(token)`.

### 5.3 Message Handling

The simplest pattern using `teloxide::repl`:

```rust
teloxide::repl(bot, |bot: Bot, msg: Message| async move {
    bot.send_message(msg.chat.id, "response").await?;
    Ok(())
}).await;
```

For more control (shared state, dependency injection), use `Dispatcher`:

```rust
let handler = Update::filter_message().endpoint(handle_message);

Dispatcher::builder(bot, handler)
    .dependencies(dptree::deps![shared_state])
    .enable_ctrlc_handler()
    .build()
    .dispatch()
    .await;
```

### 5.4 Sending Messages

```rust
bot.send_message(chat_id, text).await?;
```

Telegram message limit is 4096 characters. Long responses need chunking:

```rust
fn chunk_message(text: &str, max_len: usize) -> Vec<&str> {
    // Split text into chunks <= max_len, ideally at newline/space boundaries
}
```

### 5.5 Long-Polling Mode

teloxide's `Dispatcher::dispatch()` uses long-polling by default. No webhook server is needed for the initial implementation.

### 5.6 Graceful Shutdown

`enable_ctrlc_handler()` on the `DispatcherBuilder` handles Ctrl+C gracefully.

---

## 6. Session-per-Chat Design

### 6.1 Chat ID to Session Mapping

Each Telegram chat has a unique `ChatId` (i64). The bot must map each chat to a persistent session:

- **First message from a chat:** Create a new `Session`, store mapping
- **Subsequent messages:** Look up existing session, load history, continue conversation

### 6.2 Implementation Strategy

Use an in-memory mapping with session name convention for persistence:

```rust
type ChatSessionMap = Arc<RwLock<HashMap<i64, Uuid>>>;
```

Session naming convention: `"tg:<chat_id>"` (e.g., `"tg:123456789"`).

On startup, rebuild the map from `list_sessions()`:
```rust
async fn rebuild_chat_map(storage: &dyn SessionStore) -> HashMap<i64, Uuid> {
    let sessions = storage.list_sessions().await.unwrap_or_default();
    sessions.iter()
        .filter_map(|s| {
            s.name.as_ref()
                .and_then(|n| n.strip_prefix("tg:"))
                .and_then(|id| id.parse::<i64>().ok())
                .map(|chat_id| (chat_id, s.id))
        })
        .collect()
}
```

### 6.3 Concurrent Access

Multiple Telegram chats may send messages simultaneously. The `RwLock` ensures safe concurrent access to the session map. The SQLite WAL mode handles concurrent database writes.

---

## 7. User Authorization Design

### 7.1 Authorization Logic

Per PRD requirements:

```rust
fn is_authorized(config: &TelegramConfig, user_id: u64) -> bool {
    config.allowed_users.contains(&user_id)
}
```

Key rules:
- **Empty list = reject all** (secure by default)
- **Silent drop** for unauthorized messages (no reply, no error)
- Check `msg.from().map(|u| u.id.0)` on every incoming message

### 7.2 Implementation

Authorization should be the **first check** in the message handler, before any session lookup or agent invocation:

```rust
async fn handle_message(bot: Bot, msg: Message, config: Arc<Config>) -> ResponseResult<()> {
    let user_id = msg.from().map(|u| u.id.0).unwrap_or(0);
    let telegram_config = config.telegram.as_ref();

    // Secure default: if no telegram config or empty allowed_users, reject all
    let allowed = telegram_config
        .map(|t| t.allowed_users.contains(&user_id))
        .unwrap_or(false);

    if !allowed {
        return Ok(()); // Silent drop
    }

    // ... proceed with message handling
}
```

---

## 8. DEVIATIONS from Requirements

| # | Deviation | Requirement Source | Current State | Change Required |
|---|-----------|-------------------|---------------|-----------------|
| D1 | No `TelegramConfig` in `Config` | PRD constraint 2, `docs/phase/phase-12.md` | `Config` has `provider`, `api_key`, `model`, `session`, `mcp` -- no `telegram` field | Add `pub telegram: Option<TelegramConfig>` to `Config`, add `TelegramConfig` struct, export from `lib.rs` |
| D2 | `synapse-telegram` has no dependencies | PRD task 12.1 | `Cargo.toml` says "# No dependencies for Phase 1" | Add `teloxide`, `synapse-core`, `tokio`, `anyhow`, etc. |
| D3 | `synapse-telegram/src/main.rs` is synchronous | PRD task 12.2 | `fn main()` with `println!` only | Replace with `#[tokio::main] async fn main()` with bot initialization |
| D4 | No message handler | PRD task 12.3 | No handler code exists | Implement `handle_message()` using Agent |
| D5 | No session-per-chat persistence | PRD task 12.4 | No session management | Implement chat-to-session mapping |
| D6 | No user authorization | PRD task 12.5 | No authorization logic | Implement `allowed_users` check |
| D7 | `config.example.toml` missing `[telegram]` section | PRD | No telegram config example | Add `[telegram]` section to example |

All deviations are expected -- they represent the work to be done in this ticket. D1 is the only change to `synapse-core`; all others are within `synapse-telegram`.

---

## 9. Limitations and Risks

### 9.1 Telegram Message Length Limit

Telegram's `sendMessage` API has a 4096-character limit. LLM responses can easily exceed this. The bot must split long responses into multiple messages.

**Mitigation:** Implement a `chunk_message()` helper that splits text at paragraph/newline/space boundaries without exceeding the limit.

### 9.2 Agent Lifetime and Arc

`Agent` is not `Clone` and takes `self` in `shutdown()`. When wrapped in `Arc<Agent>`:
- Using `Agent` methods (`complete`, `stream_owned`) works fine via `&self`.
- Calling `shutdown()` requires unwrapping the `Arc`, which may fail if other references exist.

**Mitigation:** For graceful shutdown, the bot can use `Arc::try_unwrap()` after the Dispatcher stops. If unwrap fails (references still held), MCP connections will be dropped when the process exits (acceptable for initial implementation).

### 9.3 teloxide Nightly Compatibility

The project uses nightly Rust. While teloxide 0.17.0 is tested against stable, there can occasionally be nightly-only issues.

**Mitigation:** Pin teloxide to 0.17 and test during implementation. The `nightly` feature flag in teloxide enables nightly-only features if needed.

### 9.4 Concurrent Chat Sessions

Multiple Telegram users can message the bot simultaneously. Each message triggers an independent handler invocation with its own session context.

**Risk:** If the same user sends messages rapidly, two handlers could try to create a session for the same chat ID simultaneously.

**Mitigation:** Use `RwLock` for the chat-to-session map. The "create session" path should:
1. Acquire write lock
2. Check if session already exists (another handler may have created it)
3. Create only if missing
4. Release lock before calling agent (to avoid holding the lock during LLM calls)

### 9.5 SQLite Concurrent Access

Both the CLI and Telegram bot can access the same SQLite database simultaneously.

**Mitigation:** SQLite WAL mode is already configured, which allows concurrent readers and a single writer. Connection pooling (max 5 connections) is already set up.

### 9.6 Bot Token Security

The bot token must never be logged at any level.

**Mitigation:**
- Use `Bot::new(token)` -- the token is consumed and stored internally by teloxide.
- Never pass the token to `tracing` macros.
- Mask the token in any debug/error output.

### 9.7 Rate Limiting

Telegram has rate limits for bot API calls (approximately 30 messages per second, 1 message per second per chat).

**Mitigation:** For the initial implementation, no explicit rate limiting is needed. Long LLM responses (split into chunks) should include small delays between chunks. teloxide's `Throttle` bot adaptor can be enabled later if needed.

### 9.8 Streaming vs. Complete for Telegram

Unlike the CLI which streams tokens to the terminal in real-time, Telegram messages are sent atomically. There is no "typing indicator" streaming.

**Design decision:** Use `agent.complete()` rather than `agent.stream_owned()` for Telegram. This is simpler and more appropriate:
- `complete()` returns the full response at once
- The response can then be chunked and sent as Telegram message(s)
- Tool call loops are handled internally by `complete()`

Alternatively, `bot.send_chat_action(ChatAction::Typing)` can be sent before calling the agent to show a "typing..." indicator in Telegram.

---

## 10. Resolved Questions

| # | Question | Answer |
|---|----------|--------|
| Q1 | Any additional implementation constraints? | PRD has no open questions. All technical specifications (config structure, token resolution, authorization logic, session-per-chat mapping) are clearly defined in `docs/phase/phase-12.md` and the PRD. |

---

## 11. New Technical Questions Discovered During Research

| # | Question | Context |
|---|----------|---------|
| T1 | Should `agent.complete()` or `agent.stream_owned()` be used for Telegram responses? | `complete()` is simpler and more appropriate since Telegram messages are atomic (not streamed). However, `stream_owned()` allows for potential "partial response" updates (edit-in-place). Initial implementation should use `complete()`. |
| T2 | Should the chat-to-session map persist across restarts via session name convention, or should a separate mapping store be created? | Session name convention (`"tg:<chat_id>"`) is sufficient and avoids adding Telegram-specific storage. The map is rebuilt from `list_sessions()` on startup. |
| T3 | How to handle the `Agent::shutdown()` taking `self` when `Agent` is in `Arc`? | Options: (a) `Arc::try_unwrap()` after dispatcher stops, (b) add a `shutdown_ref(&self)` method to Agent, (c) accept that MCP connections are dropped on process exit. Option (a) or (c) is simplest for initial implementation. |
| T4 | Should a "typing" indicator be sent before long LLM calls? | `bot.send_chat_action(msg.chat.id, ChatAction::Typing)` can be sent before calling the agent. This is a small UX improvement that should be included. |
| T5 | How to handle errors from the Agent in Telegram? | Unlike the CLI which can print to stderr, the Telegram bot should log errors via `tracing` and optionally send a user-friendly error message (e.g., "Sorry, I encountered an error. Please try again."). |
| T6 | Should `TelegramConfig` derive `Default`? | Yes, with `token: None` and `allowed_users: vec![]`. This ensures that if no `[telegram]` section exists in config, the bot can still check authorization (which will reject all users due to empty list -- secure default). |

---

## 12. File Inventory: Files That Must Change

| File | Change Type | Description |
|------|-------------|-------------|
| `synapse-core/src/config.rs` | Modify | Add `TelegramConfig` struct, add `pub telegram: Option<TelegramConfig>` to `Config`, add `Default` impl |
| `synapse-core/src/lib.rs` | Modify | Export `TelegramConfig` |
| `synapse-telegram/Cargo.toml` | Modify | Add all required dependencies (`teloxide`, `synapse-core`, `tokio`, `anyhow`, `futures`, `uuid`, `tracing`, `tracing-subscriber`) |
| `synapse-telegram/src/main.rs` | Rewrite | Bot entry point with initialization, config loading, token resolution, agent/storage creation, dispatcher setup |
| `synapse-telegram/src/handlers.rs` | **Create** | Message handler with authorization, session management, agent invocation, response sending |
| `config.example.toml` | Modify | Add `[telegram]` section with example values |

### Files NOT modified (confirming constraint 1):

- `synapse-core/src/agent.rs` -- no changes needed
- `synapse-core/src/provider.rs` -- no changes needed
- `synapse-core/src/storage.rs` -- no changes needed
- `synapse-core/src/mcp.rs` -- no changes needed
- `synapse-cli/` -- no changes needed

---

## 13. Proposed Architecture

```
                         Telegram API (long-polling)
                                |
                                v
                    +------------------------+
                    |  synapse-telegram      |
                    |  main.rs              |
                    |  - Config::load()     |
                    |  - resolve_bot_token() |
                    |  - create_provider()  |
                    |  - create_storage()   |
                    |  - init_mcp_client()  |
                    |  - Agent::new()       |
                    |  - Dispatcher setup   |
                    +----------+-------------+
                               |
                    +----------v-------------+
                    |  handlers.rs           |
                    |  - handle_message()    |
                    |    1. Auth check       |
                    |    2. Session lookup   |
                    |    3. Load history     |
                    |    4. agent.complete() |
                    |    5. Store messages   |
                    |    6. Send response    |
                    +----------+-------------+
                               |
                    +----------v-------------+
                    |  synapse-core          |
                    |  (Agent, SessionStore, |
                    |   LlmProvider, MCP)    |
                    +------------------------+
```

### Shared State (injected via dptree::deps![])

| Type | Purpose |
|------|---------|
| `Arc<Config>` | Read-only configuration |
| `Arc<Agent>` | LLM + MCP orchestrator |
| `Arc<Box<dyn SessionStore>>` | Session persistence |
| `Arc<RwLock<HashMap<i64, Uuid>>>` | Chat ID to session ID mapping |

---

## 14. Summary

SY-13 (Telegram Bot) is a clean validation of the hexagonal architecture. Unlike SY-12 (MCP Integration) which was deeply cross-cutting, this ticket has a small footprint in `synapse-core` (one config struct addition) and all new code lives in `synapse-telegram`.

The core technical challenges are:
1. **teloxide integration** -- setting up the Dispatcher with dependency injection for shared state (`Agent`, `SessionStore`, `Config`)
2. **Session-per-chat mapping** -- efficiently mapping Telegram chat IDs to persistent sessions using the session name convention
3. **User authorization** -- implementing the allowlist check with secure-by-default behavior
4. **Message handling** -- receiving messages, invoking the Agent, chunking long responses, and sending them back

The implementation should follow the CLI's initialization pattern closely, replacing the CLI-specific parts (clap, ratatui) with Telegram-specific ones (teloxide dispatcher, message handlers).
