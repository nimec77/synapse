# SY-20 Research: Improve /history Command

## 1. Existing Endpoints and Contracts

### cmd_history (commands.rs:184-239)

The current implementation of `cmd_history` retrieves ALL messages from the active session and formats them without filtering or truncation:

```rust
async fn cmd_history(
    bot: &Bot,
    msg: &TgMessage,
    storage: &Arc<Box<dyn SessionStore>>,
    chat_map: &ChatSessionMap,
) -> ResponseResult<()> {
    // ... session lookup ...
    let messages = storage.get_messages(session_id).await.unwrap_or_default();
    // ... empty check ...

    let mut output = String::new();
    for m in &messages {
        let role_label = match m.role {
            synapse_core::message::Role::User => "You",
            synapse_core::message::Role::Assistant => "Assistant",
            synapse_core::message::Role::System => "System",
            synapse_core::message::Role::Tool => "Tool",
        };
        let timestamp = chrono::Utc
            .from_utc_datetime(&m.timestamp.naive_utc())
            .format("%Y-%m-%d %H:%M")
            .to_string();
        output.push_str(&format!(
            "[{}] {}\n{}\n\n",
            role_label, timestamp, m.content
        ));
    }

    for chunk in chunk_message(output.trim()) {
        bot.send_message(msg.chat.id, chunk).await?;
    }
    Ok(())
}
```

**Issues to fix (per PRD):**
1. Iterates ALL messages, including `Role::System` and `Role::Tool`.
2. No limit on the number of messages shown.
3. No truncation of long message content.

### Command::History Description (commands.rs:37)

Current:
```rust
#[command(description = "Show conversation history")]
History,
```

Target:
```rust
#[command(description = "Show recent messages")]
History,
```

### StoredMessage (session.rs:82-128)

The messages returned by `storage.get_messages()` are `Vec<StoredMessage>`, each containing:
- `role: Role` -- used for filtering (keep only `User` and `Assistant`)
- `content: String` -- needs truncation to 150 chars
- `timestamp: DateTime<Utc>` -- used for display formatting

Messages are returned in chronological order (`timestamp ASC`) from the storage layer, as documented in `SessionStore::get_messages()`.

### Role Enum (message.rs:9-20)

```rust
pub enum Role {
    System,
    User,
    Assistant,
    Tool,
}
```

The filter must keep only `User` and `Assistant`, discarding `System` and `Tool`.

## 2. Layers and Dependencies

### Dependency Flow

```
cmd_history (commands.rs)
  ├── storage.get_messages(session_id) -> Vec<StoredMessage>
  ├── synapse_core::message::Role (for role matching/filtering)
  ├── chrono (for timestamp formatting)
  └── chunk_message (from handlers.rs, for Telegram message splitting)
```

All changes are confined to `synapse-telegram/src/commands.rs`. No changes to `synapse-core` or `synapse-cli` are needed.

### Crate Dependencies

No new crate dependencies are required. All needed functionality (`chrono`, `synapse_core::message::Role`, `chunk_message`) is already imported in `commands.rs`.

## 3. Patterns Used

### Truncation Pattern

Two truncation patterns exist in the codebase:

1. **Character-based truncation with `.chars().take(N)`** -- used in `cmd_list` (line 286-292) and `build_session_keyboard` (line 357-362):
   ```rust
   let preview = s.preview.as_deref().unwrap_or("")
       .chars()
       .take(40)
       .collect::<String>();
   ```
   This operates on Unicode scalar values, safe for multi-byte characters.

2. **Byte-based truncation with `...` suffix** -- used in `synapse-cli/src/commands.rs` (`truncate` function):
   ```rust
   pub(crate) fn truncate(s: &str, max_len: usize) -> String {
       if s.len() <= max_len {
           s.to_string()
       } else if max_len <= 3 {
           ".".repeat(max_len)
       } else {
           format!("{}...", &s[..max_len - 3])
       }
   }
   ```
   This uses byte length and slicing, which is not Unicode-safe.

**PRD mandates pattern #1** (`.chars().take(150)`) with `...` appended when truncation occurs. The implementation should combine both: use `.chars().take(150).collect::<String>()` for truncation and append `...` when the original content exceeds 150 characters.

### Filter and Limit Pattern

The "filter then take last N" pattern does not exist in the current codebase. The implementation will:
1. Filter `messages` to keep only `Role::User` and `Role::Assistant`.
2. Take the last 10 from the filtered list (since messages are in chronological order, use `.rev().take(10).rev()` or equivalent to get the last 10 while preserving order).

A cleaner approach: if `N` is the total filtered count, skip the first `N - 10` (clamped to 0), which avoids double reversal:
```rust
let filtered: Vec<&StoredMessage> = messages.iter()
    .filter(|m| matches!(m.role, Role::User | Role::Assistant))
    .collect();
let skip = filtered.len().saturating_sub(10);
let recent = &filtered[skip..];
```

### Testable Helper Functions (PRD Constraint)

The PRD explicitly requires: "The filtering/truncation logic should be extracted into testable helper functions (not embedded inline in the async handler)."

Two helper functions are needed:

1. **`truncate_content(content: &str, max_chars: usize) -> String`** -- Truncates to `max_chars` characters, appending `...` if truncated. Returns the content unchanged (as a `String`) if within limit.

2. **`format_history(messages: &[StoredMessage]) -> String`** -- Filters to User/Assistant roles, takes the last 10, truncates each to 150 chars, and formats into the display string. Returns the formatted output or an empty string if no messages pass the filter.

Alternatively, the filtering/truncation could be a single function that takes the full `Vec<StoredMessage>` and returns the formatted output. The `cmd_history` async handler would then only handle session lookup and sending the result.

## 4. Existing Test Infrastructure

### Current Test Count

68 tests passing in `synapse-telegram`:
- `commands::tests` -- 25 tests (parse_session_arg, parse_callback_data, build_session_keyboard, ChatSessions, session cap, index validation, delete active_idx adjustment)
- `format::tests` -- 25 tests (escape_html, md_to_telegram_html, chunk_html)
- `handlers::tests` -- 7 tests (authorization, message chunking)
- `tests` (main.rs) -- 11 tests (token resolution, chat map rebuilding)

### Test Patterns

Tests in `commands.rs` use plain `#[test]` (not `#[tokio::test]`) for synchronous logic. The helper functions for filtering and truncation are pure synchronous functions, so the same pattern applies.

The existing `make_session` helper in `commands::tests` constructs `SessionSummary` instances. For history tests, we need a similar helper to construct `StoredMessage` instances.

### Required Tests (from PRD)

1. Role filtering -- only User/Assistant pass through
2. Last-10 limit -- correct messages selected from a longer list
3. Truncation at 150 chars with ellipsis
4. No truncation for short messages
5. Edge case: exactly 150 chars (no ellipsis)
6. Edge case: 151 chars (truncated to 150 + ellipsis)

## 5. Documentation State

### CLAUDE.md (Already Updated)

The `synapse-telegram` entry in the Workspace Crates table already describes `/history` as "(last 10 messages, truncated to 150 chars)". No update needed.

### README.md (Already Updated)

Line 139 already reads: `| /history | Show recent messages from the current session |`. No update needed.

### CHANGELOG.md (Already Updated)

The `[Unreleased]` section (line 10-12) already contains:
```
### Changed

- `/history` now shows the last 10 user/assistant messages (truncated to 150 chars) instead of dumping the full conversation.
```

No update needed.

## 6. Implementation Plan per Task

### Task 20.1: Update cmd_history

1. Extract a `truncate_content(content: &str, max_chars: usize) -> String` helper function:
   ```rust
   fn truncate_content(content: &str, max_chars: usize) -> String {
       let char_count = content.chars().count();
       if char_count <= max_chars {
           content.to_string()
       } else {
           let truncated: String = content.chars().take(max_chars).collect();
           format!("{}...", truncated)
       }
   }
   ```

2. Extract a `format_history(messages: &[StoredMessage]) -> String` helper function:
   - Filter to `Role::User | Role::Assistant`
   - Take last 10 (chronological order preserved)
   - Format each: `[role_label] timestamp\ntruncated_content\n\n`
   - Return the joined output (or empty string)

3. Simplify `cmd_history` to:
   - Session lookup (unchanged)
   - `storage.get_messages()` (unchanged)
   - Call `format_history(&messages)`
   - If empty, reply "No messages in current session."
   - Otherwise, chunk and send

### Task 20.2: Update Command Description

Change line 37 from:
```rust
#[command(description = "Show conversation history")]
```
To:
```rust
#[command(description = "Show recent messages")]
```

### Task 20.3: Add Unit Tests

Tests for `truncate_content`:
- `test_truncate_content_short` -- content within limit, no ellipsis
- `test_truncate_content_exact_limit` -- exactly 150 chars, no ellipsis
- `test_truncate_content_over_limit` -- 151 chars, truncated to 150 + `...`
- `test_truncate_content_long` -- much longer content, verify truncation

Tests for `format_history`:
- `test_format_history_filters_system_and_tool` -- System and Tool messages excluded
- `test_format_history_keeps_user_and_assistant` -- User and Assistant messages included
- `test_format_history_last_10_limit` -- more than 10 User/Assistant messages, only last 10 shown
- `test_format_history_fewer_than_10` -- fewer than 10, all shown
- `test_format_history_empty` -- no User/Assistant messages (all System/Tool), returns empty
- `test_format_history_truncates_long_content` -- verifies content truncation within formatted output

### Task 20.4: Update Documentation

All three documentation targets (CLAUDE.md, README.md, CHANGELOG.md) are already up to date. No changes needed.

## 7. Limitations and Risks

### Performance of Full Message Retrieval

`storage.get_messages(session_id)` returns ALL messages before filtering. For sessions with hundreds of messages (especially with tool calls creating many System/Tool messages), this could be slow. The PRD acknowledges this and considers it acceptable for Telegram usage patterns.

### Character Count vs Display Width

Truncation at 150 Unicode characters does not guarantee consistent visual width because characters have variable display widths (e.g., CJK characters are typically double-width, emoji may vary). This is consistent with the existing `.chars().take()` pattern used elsewhere in the codebase and is acceptable for the Telegram bot context.

### Message Ordering Assumption

The implementation assumes `storage.get_messages()` returns messages in chronological order (`timestamp ASC`). This is guaranteed by the `SessionStore` trait documentation and the SQLite implementation's `ORDER BY timestamp ASC` clause.

## 8. Resolved Questions

No open questions existed in the PRD. The user confirmed default implementation approach.

Key decisions already documented in the PRD:
- Character-based truncation (`.chars().take(150)`), not byte-based
- Ellipsis is `...` (three ASCII dots), not Unicode ellipsis `\u{2026}`
- "Last 10" means chronologically last after filtering
- Helper functions must be extracted for testability
- Plain text output (no `ParseMode::Html`), matching existing command convention

## 9. New Technical Questions Discovered

None. The PRD is comprehensive and all implementation details are clearly specified. The existing codebase patterns (`.chars().take()` for truncation, `StoredMessage` structure, `Role` enum matching) directly support the required changes.

## 10. Deviations from Requirements

None identified. The current `cmd_history` implementation simply lacks the filtering, limiting, and truncation features described in the PRD. The existing code will be refactored to add these features without contradicting any requirements.
