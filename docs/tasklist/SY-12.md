# SY-12 Tasklist: MCP Integration (Phase 11)

Status: DONE

## Context

Integrate the Model Context Protocol (MCP) into Synapse, enabling tool calling via external MCP servers. This is a cross-cutting change touching the data model, all LLM providers, configuration, storage, and both CLI modes. The implementation adds: MCP client infrastructure for stdio-based MCP servers, tool discovery and a unified tool registry, tool-aware LLM provider APIs, an agent orchestrator for the detect-execute-return tool call loop, data model extensions for `Role::Tool` and tool calls/results on messages with a database migration, and integration of the agent loop into both CLI one-shot and REPL modes.

## Tasks

- [x] **Task 1: Extend data model with `Role::Tool`, `ToolCallData`, and `Message` tool fields**
  In `synapse-core/src/message.rs`: add `Tool` variant to `Role` enum. Create `ToolCallData` struct with `id: String`, `name: String`, `input: serde_json::Value`. Extend `Message` struct with `tool_calls: Option<Vec<ToolCallData>>` and `tool_call_id: Option<String>`. Keep `Message::new()` backward compatible (new fields default to `None`). Add `Message::tool_result(tool_call_id, content)` builder method that creates a `Role::Tool` message.
  - **AC1:** `Role::Tool` serializes to `"tool"` and `"tool"` deserializes to `Role::Tool`.
  - **AC2:** `Message::new(Role::User, "hello")` still works, `tool_calls` and `tool_call_id` are `None`.
  - **AC3:** `Message::tool_result("call_1", "result text")` creates a message with `Role::Tool`, `tool_call_id = Some("call_1")`, and `content = "result text"`.
  - **AC4:** `Message` with `tool_calls` populated serializes/deserializes correctly.

- [x] **Task 2: Extend `StoredMessage` with tool columns and add database migration**
  In `synapse-core/src/session.rs`: add `tool_calls: Option<String>` and `tool_results: Option<String>` fields to `StoredMessage`. Update `StoredMessage::new()` to default these to `None`. Add builder methods for constructing messages with tool data. Create migration file `synapse-core/migrations/20260208_002_add_tool_columns.sql` with `ALTER TABLE messages ADD COLUMN tool_calls TEXT; ALTER TABLE messages ADD COLUMN tool_results TEXT;`.
  - **AC1:** `StoredMessage::new(...)` still works, `tool_calls` and `tool_results` default to `None`.
  - **AC2:** Migration file exists and contains the correct `ALTER TABLE` statements.
  - **AC3:** `StoredMessage` can be constructed with tool data fields populated.

- [x] **Task 3: Update `SqliteStore` for `Role::Tool` and tool columns**
  In `synapse-core/src/storage/sqlite.rs`: add `"tool" => Ok(Role::Tool)` to `parse_role()` and `Role::Tool => "tool"` to `role_to_string()`. Update `add_message()` SQL to bind `tool_calls` and `tool_results` columns. Update `get_messages()` SQL to read `tool_calls` and `tool_results` columns from rows.
  - **AC1:** `test_sqlite_role_tool_roundtrip` passes -- store and retrieve a `Role::Tool` message.
  - **AC2:** `test_sqlite_tool_calls_roundtrip` passes -- store and retrieve messages with `tool_calls` JSON.
  - **AC3:** Existing storage tests continue to pass (no regression).

- [x] **Task 4: Create MCP error type and module structure**
  Create `synapse-core/src/mcp.rs` as the parent module with `McpError` enum (variants: `ConfigError(String)`, `ConnectionError { server, message }`, `ToolError(String)`, `IoError(String)`) using `thiserror`. Add `mod protocol; mod tools;` declarations. Add `pub mod mcp;` to `synapse-core/src/lib.rs`. Create placeholder files `synapse-core/src/mcp/protocol.rs` and `synapse-core/src/mcp/tools.rs`.
  - **AC1:** `McpError` variants all implement `Display` and `Error` correctly.
  - **AC2:** `cargo check -p synapse-core` succeeds with the new module structure.

- [x] **Task 5: Implement MCP configuration types and loading**
  In `synapse-core/src/mcp/protocol.rs`: define `McpServerConfig` (fields: `command`, `args`, `env`), `McpConfig` (field: `mcp_servers` with `#[serde(rename = "mcpServers")]`), and `ToolDefinition` (fields: `name`, `description: Option<String>`, `input_schema: serde_json::Value`). In `synapse-core/src/mcp.rs`: implement `load_mcp_config()` with path resolution (`SYNAPSE_MCP_CONFIG` env var > `~/.config/synapse/mcp_servers.json`), returning `Ok(None)` if no config file exists. Re-export types via `pub use`.
  - **AC1:** `test_mcp_config_parse` passes -- standard `mcp_servers.json` format parses correctly.
  - **AC2:** `test_mcp_config_empty` passes -- empty `mcpServers` map parses.
  - **AC3:** `test_mcp_config_with_env` passes -- server config with environment variables.
  - **AC4:** `test_load_mcp_config_missing_file` passes -- returns `None` when file is absent.
  - **AC5:** `test_tool_definition_serialization` passes -- `ToolDefinition` round-trip.

- [x] **Task 6: Implement `McpClient` with tool discovery and execution**
  In `synapse-core/src/mcp/tools.rs`: implement `McpClient` struct with `servers: HashMap<String, RunningClient>`, `tool_registry: HashMap<String, String>`, `tool_definitions: Vec<ToolDefinition>`. Implement `McpClient::new(config)` that spawns child processes via `TokioChildProcess`, connects via `rmcp`, discovers tools via `list_tools()`, and registers them. Implement `call_tool(name, input)` for tool execution, `tool_definitions()` getter, `has_tools()` check, and `shutdown()` for graceful cleanup. Servers that fail to start are logged as warnings but do not prevent initialization. Add `rmcp` dependency to `synapse-core/Cargo.toml` with features `client`, `transport-child-process`, `transport-io`. Add `process` feature to `tokio`.
  - **AC1:** `test_mcp_client_no_servers` passes -- empty config produces client with no tools.
  - **AC2:** `test_call_tool_unknown_name` passes -- returns `McpError::ToolError` for unknown tool.
  - **AC3:** `test_has_tools_empty` passes -- `has_tools()` returns false when no tools.
  - **AC4:** `test_has_tools_populated` passes -- `has_tools()` returns true when tools present.

- [x] **Task 7: Extend `LlmProvider` trait with tool-aware methods**
  In `synapse-core/src/provider.rs`: add `complete_with_tools(&self, messages: &[Message], tools: &[ToolDefinition]) -> Result<Message, ProviderError>` with default implementation delegating to `complete()`. Add `stream_with_tools(&self, messages: &[Message], tools: &[ToolDefinition]) -> Pin<Box<dyn Stream<...>>>` with default implementation delegating to `stream()`. Import `ToolDefinition` from `crate::mcp`. Re-export `ToolDefinition` from `lib.rs`.
  - **AC1:** `MockProvider` continues to work via default implementations (no changes needed to mock).
  - **AC2:** `cargo check -p synapse-core` succeeds with the new trait methods.
  - **AC3:** Existing provider tests pass without modification.

- [x] **Task 8: Implement Anthropic provider tool calling support**
  In `synapse-core/src/provider/anthropic.rs`: add `AnthropicTool` struct (`name`, `description`, `input_schema`). Add `tools: Option<Vec<AnthropicTool>>` to `ApiRequest` with `skip_serializing_if`. Extend `ContentBlock` parsing for `type: "tool_use"` blocks (`id`, `name`, `input`). Implement `complete_with_tools()` override that includes tool definitions and parses tool call responses into `Message` with `tool_calls`. Handle `Role::Tool` messages by translating to Anthropic's `user` role with `tool_result` content blocks.
  - **AC1:** `test_complete_with_tools_serialization` passes -- tool definitions serialized in Anthropic format (`name`, `description`, `input_schema`).
  - **AC2:** `test_tool_call_response_parsing` passes -- response with `tool_use` content block parsed into `Message.tool_calls`.
  - **AC3:** `test_tool_role_message_serialization` passes -- `Role::Tool` message serialized as `user` role with `tool_result` content block.
  - **AC4:** `test_complete_with_tools_no_tools` passes -- empty tools array omitted from request.

- [x] **Task 9: Implement OpenAI provider tool calling support**
  In `synapse-core/src/provider/openai.rs`: add `OpenAiTool`, `OpenAiFunction`, `OpenAiToolCall`, `OpenAiToolCallFunction` structs. Add `tools: Option<Vec<OpenAiTool>>` to `ApiRequest` and `StreamingApiRequest` with `skip_serializing_if`. Extend `ChoiceMessage` with `tool_calls: Option<Vec<OpenAiToolCall>>`. Add `StreamToolCallDelta` and `StreamFunctionDelta` for streaming tool call accumulation. Handle `Role::Tool` in `ApiMessage` mapping to `"tool"` with `tool_call_id` field. Implement `complete_with_tools()` and `stream_with_tools()` overrides. Handle `finish_reason: "tool_calls"` in streaming.
  - **AC1:** `test_complete_with_tools_serialization` passes -- tool definitions in OpenAI format (`type: "function"`, `function: { name, description, parameters }`).
  - **AC2:** `test_tool_call_response_parsing` passes -- response with `tool_calls` array parsed into `Message.tool_calls`.
  - **AC3:** `test_tool_role_message_serialization` passes -- `Role::Tool` message serialized with `role: "tool"` and `tool_call_id`.
  - **AC4:** `test_complete_with_tools_no_tools` passes -- empty tools array omitted from request.

- [x] **Task 10: Implement DeepSeek provider tool calling support**
  In `synapse-core/src/provider/deepseek.rs`: apply the same changes as the OpenAI provider (DeepSeek uses the OpenAI-compatible format). Add private API types for tools, extend request/response structs, implement `complete_with_tools()` and `stream_with_tools()` overrides, handle `Role::Tool` in message serialization.
  - **AC1:** `test_complete_with_tools_serialization` passes -- tool definitions in OpenAI-compatible format.
  - **AC2:** `test_tool_call_response_parsing` passes -- response with `tool_calls` parsed correctly.
  - **AC3:** `test_tool_role_message_serialization` passes -- `Role::Tool` message serialized correctly.
  - **AC4:** `test_complete_with_tools_no_tools` passes -- empty tools array omitted.

- [x] **Task 11: Extend `MockProvider` for tool call testing**
  In `synapse-core/src/provider/mock.rs`: handle `Role::Tool` in any match arms. Add `with_tool_call_response()` builder method to configure mock tool call responses (returning a `Message` with `tool_calls` populated). This enables testing the agent loop without real providers.
  - **AC1:** `MockProvider` handles `Role::Tool` messages without panicking.
  - **AC2:** `with_tool_call_response()` configures the mock to return a message with tool calls on the first call and a text response on subsequent calls.

- [x] **Task 12: Implement Agent orchestrator with tool call loop**
  Create `synapse-core/src/agent.rs`: define `AgentError` enum (variants: `Provider(ProviderError)`, `Mcp(McpError)`, `MaxIterationsExceeded`). Define `Agent` struct with `provider: Box<dyn LlmProvider>` and `mcp_client: Option<McpClient>`. Implement `Agent::new()`, `Agent::complete()` (loops up to 10 iterations: sends messages with tools to provider, if tool calls returned executes via MCP client, appends results, re-sends; otherwise returns text response), and `Agent::stream()` (uses `complete_with_tools()` for tool iterations, yields final response as `TextDelta` + `Done`; or delegates directly to `provider.stream()` when no tools). Add `pub mod agent;` and exports to `lib.rs`.
  - **AC1:** `test_agent_complete_no_tools` passes -- Agent without MCP client delegates to provider.
  - **AC2:** `test_agent_complete_with_tool_call` passes -- mock provider returns tool call, mock MCP executes, provider called again with result.
  - **AC3:** `test_agent_complete_multiple_tool_calls` passes -- multiple tool calls in one response handled.
  - **AC4:** `test_agent_complete_max_iterations` passes -- returns `MaxIterationsExceeded` after 10 iterations.
  - **AC5:** `test_agent_stream_no_tools` passes -- streaming without tools returns provider stream directly.
  - **AC6:** `test_agent_complete_tool_error_forwarded` passes -- MCP tool error forwarded to LLM as error result.

- [x] **Task 13: Integrate MCP and Agent into CLI one-shot mode**
  In `synapse-cli/src/main.rs`: after loading config, load MCP config via `load_mcp_config()`. Initialize `McpClient` if config exists (with warning on failure). Create `Agent` wrapping provider and optional MCP client. Replace direct `provider.stream(&messages)` call with `agent.stream(&mut messages)`. Remove the `Some(Ok(_)) => {}` arm for ToolCall/ToolResult (agent handles internally). Add `Role::Tool => "[TOOL]"` display arm for `sessions show` command. Ensure MCP client shutdown on exit.
  - **AC1:** One-shot mode works with Agent wrapping the provider (no behavioral regression without MCP config).
  - **AC2:** `Role::Tool` displays as `"[TOOL]"` in session history.
  - **AC3:** MCP config loading errors produce warnings, not crashes.

- [x] **Task 14: Integrate MCP and Agent into CLI REPL mode**
  In `synapse-cli/src/repl.rs`: accept `McpClient` (optional) as parameter or construct internally. Create `Agent` wrapping provider and MCP client. Replace `provider.stream(&conv_messages)` with `agent.stream(&mut conv_messages)`. Remove the `Some(Ok(_)) => {}` arm for ToolCall/ToolResult. Add `Role::Tool => ("[TOOL]", Color::Magenta)` arm to `build_history_lines()` for display.
  - **AC1:** REPL mode works with Agent wrapping the provider (no behavioral regression without MCP config).
  - **AC2:** `Role::Tool` displays as `"[TOOL]"` with magenta color in history.
  - **AC3:** Tool call messages in history are rendered correctly.

- [x] **Task 15: Update `lib.rs` exports and verify module structure**
  Verify `synapse-core/src/lib.rs` has all new exports: `pub mod agent;`, `pub mod mcp;`, `pub use agent::{Agent, AgentError};`, `pub use mcp::{McpClient, McpConfig, McpError, McpServerConfig, ToolDefinition, load_mcp_config};`, `pub use message::{..., ToolCallData};`. Verify no `mod.rs` files were created. Verify module structure matches the plan.
  - **AC1:** All public types are importable from `synapse_core::*`.
  - **AC2:** No `mod.rs` files exist in the new module tree.
  - **AC3:** `cargo check` succeeds for the entire workspace.

- [x] **Task 16: Run full test suite and verify no regressions**
  Run `cargo fmt --check && cargo clippy -- -D warnings && cargo test` to verify all existing tests pass, formatting is correct, and there are no linting warnings. Verify all new tests pass. Ensure backward compatibility: without `mcp_servers.json`, Synapse behaves identically to pre-MCP.
  - **AC1:** All existing tests pass (no regressions).
  - **AC2:** All new tests pass (~37 new tests per the plan).
  - **AC3:** `cargo clippy -- -D warnings` reports no warnings.
  - **AC4:** `cargo fmt --check` passes.
